<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>tac.vibe</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="index.css">
  <style>
    /* Ensure the chat header positions its children relative to it */
    #chatHeader {
      position: relative;
    }
    /* Position the settings button to the right side of block header instead of center */
    #settingsButton {
      position: absolute;
      top: 0;
      right: 0;
    }
    /* CSS for blockStatus removed as it's now in the stylesheet */
  </style>
</head>
<body>
  <div id="splitContainer">
    <div id="chatPanel">
      <div id="chatHeader">
        <div id="recipientName">tac.vibe</div>
        <div id="typingAnimation">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </div>
        <div id="recipientStatus">
          <span class="statusDot"></span>
          <span id="statusText">connecting...</span>
        </div>
      </div>
      <div id="messageContainer"></div>
      <div id="gitOperationsPanel" class="initially-hidden">
        <div class="section-title">Git Operations</div>
        <div class="git-buttons">
          <button id="commitChangesBtn" class="git-button">Commit Changes</button>
          <button id="discardChangesBtn" class="git-button">Discard Changes</button>
          <div class="merge-container">
            <button id="mergeBtn" class="git-button">Merge with Branch</button>
            <select id="branchSelect" class="branch-select">
              <option value="">Select Branch</option>
            </select>
          </div>
        </div>
      </div>
      <div id="inputContainer">
        <textarea id="userInput" placeholder="Type your message here..." rows="2"></textarea>
        <div id="buttonContainer">
          <div id="micButton" class="action-button">üé§</div>
          <div id="blockButton" class="action-button">
            <canvas id="cubeCanvas" width="32" height="32"></canvas>
          </div>
        </div>
      </div>
    </div>
    <div id="blockPanel">
      <div id="blockHeader">
        <div id="blockTitle">Block Status</div>
        <div id="blockStatus">
          <span class="statusDot blockStatusDot"></span>
          <span id="blockStatusText">Ready...</span>
        </div>
        <div id="settingsButton" class="action-button">‚öôÔ∏è</div>
      </div>
      <div id="errorMessage"></div>
      <div id="infoMessage"></div>
      <div id="protoblockContainer">
        <!-- Protoblock container structure -->
        <div id="protoblockHeader">
          <h2>Protoblock</h2>
          <p id="protoblockAttempt">Attempt 1/4</p>
        </div>
        <div class="section">
          <div class="section-title">Task Description</div>
          <div id="taskDescription" class="code-block"></div>
        </div>
        <div class="section">
          <div class="section-title">Files to Modify</div>
          <ul id="writeFilesList" class="file-list"></ul>
        </div>
        <div class="section">
          <div class="section-title">Trusty Agents</div>
          <div id="trustyAgentsSection">
            <ul id="trustyAgentsList" class="file-list"></ul>
            
          </div>
        </div>
      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    // Utility functions for showing and hiding elements
    function hideElement(element) {
      if (typeof element === 'string') {
        element = document.getElementById(element) || document.querySelector(element);
      }
      if (element) {
        // Just set display to none for consistency with existing code
        element.style.display = 'none';
        
        // Also update classes for future use
        element.classList.add('hidden');
        element.classList.remove('visible');
        element.classList.remove('display-flex');
      }
    }
    
    function showElement(element, displayType = 'block') {
      if (typeof element === 'string') {
        element = document.getElementById(element) || document.querySelector(element);
      }
      if (element) {
        // Set the display style directly for compatibility with existing code
        element.style.display = displayType;
        
        // Also update classes for future use
        element.classList.remove('hidden');
        if (displayType === 'flex') {
          element.classList.add('display-flex');
        } else {
          element.classList.add('visible');
        }
      }
    }
    
    function toggleElement(element, displayType = 'block') {
      if (typeof element === 'string') {
        element = document.getElementById(element) || document.querySelector(element);
      }
      if (element) {
        if (element.style.display === 'none' || getComputedStyle(element).display === 'none') {
          showElement(element, displayType);
        } else {
          hideElement(element);
        }
      }
    }

    // Initialize Three.js scene in the block panel
    const threeContainer = document.getElementById('blockPanel');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, threeContainer.clientWidth / threeContainer.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(threeContainer.clientWidth, threeContainer.clientHeight);
    renderer.setClearColor(0xe0eafc, 1);
    threeContainer.appendChild(renderer.domElement);

    // Create a polished cube with a refined material configured with wireframe: true
    const geometry = new THREE.BoxGeometry();
    const cubeMaterial = new THREE.MeshPhongMaterial({ 
      color: 0x0078d7, 
      shininess: 100, 
      wireframe: true, 
      transparent: true, 
      opacity: 0.7,
      emissive: 0x0078d7,
      emissiveIntensity: 0.5
    });
    const cube = new THREE.Mesh(geometry, cubeMaterial);
    // Center the cube horizontally within the scene
    cube.position.x = 0;
    scene.add(cube);

    // Add a wireframe overlay using EdgesGeometry and LineSegments for added style
    const edges = new THREE.EdgesGeometry(geometry);
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
    const wireframe = new THREE.LineSegments(edges, lineMaterial);
    cube.add(wireframe);

    // Position the camera and add lights for a refined look
    camera.position.set(3, 3, 5);
    camera.lookAt(0, 0, 0);
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    function animate() {
      requestAnimationFrame(animate);
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;
      renderer.render(scene, camera);
    }
    animate();

    // Function to toggle between 3D cube and protoblock display
    function toggleProtoblockDisplay(show) {
      const protoblockContainer = document.getElementById('protoblockContainer');
      const canvas = renderer.domElement;
      
      if (show) {
        // First show the protoblock container
        showElement(protoblockContainer);
        
        // Use a smooth transition for the canvas
        canvas.style.opacity = '0';
        setTimeout(() => {
          hideElement(canvas);
          // Ensure the header has proper background
          document.getElementById('blockHeader').style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
        }, 300);
      } else {
        // Show the canvas first
        showElement(canvas);
        setTimeout(() => {
          canvas.style.opacity = '1';
          // Hide the protoblock container
          hideElement(protoblockContainer);
          // Reset background for cube view
          document.getElementById('blockHeader').style.backgroundColor = 'transparent';
          document.getElementById('blockHeader').style.boxShadow = 'none';
        }, 50);
      }
    }

    // Function to update the status with appropriate styling
    function updateRuntimeStatus(message, status = "default") {
      const statusTextElement = document.getElementById("blockStatusText");
      const statusDotElement = document.querySelector("#blockStatus .blockStatusDot");
      
      if (!statusTextElement || !statusDotElement) return;
      
      // Update status element
      statusTextElement.textContent = message;
      
      // Remove all status classes from text and dot
      statusTextElement.classList.remove("processing", "success", "error", "default");
      statusDotElement.classList.remove("processing", "success", "error", "default", "online", "offline");
      
      // Add appropriate class based on status
      if (status === "processing") {
        statusTextElement.classList.add("processing");
        statusDotElement.classList.add("processing"); // Yellow dot for processing
      } else if (status === "success") {
        statusTextElement.classList.add("success");
        statusDotElement.classList.add("success"); // Green dot for success
      } else if (status === "error") {
        statusTextElement.classList.add("error");
        statusDotElement.classList.add("error"); // Red dot for error
      } else {
        statusTextElement.classList.add("default");
        statusDotElement.classList.add("online"); // Default to green/online dot
      }
    }
    
    // Function to handle block execution failure
    function handleBlockFailure() {
      // Hide the protoblock display completely
      toggleProtoblockDisplay(false);
      
      // Reset any protoblock data displayed
      document.getElementById('protoblockContainer').innerHTML = '';
      
      // Rebuild the container structure
      rebuildProtoblockContainer();
      
      // Update the runtime status to show error
      updateRuntimeStatus("Block execution failed", "error");
    }
    
    // Function to rebuild the empty protoblock container structure
    function rebuildProtoblockContainer() {
      const container = document.getElementById('protoblockContainer');
      
      // Clear the container first
      container.innerHTML = '';
      
      // Header
      const header = document.createElement('div');
      header.id = 'protoblockHeader';
      header.innerHTML = '<h2>Protoblock</h2>' +
                         '<p id="protoblockAttempt">Attempt 1/4</p>';
      container.appendChild(header);
      
      // Task Description
      const taskSection = document.createElement('div');
      taskSection.className = 'section';
      taskSection.innerHTML = '<div class="section-title">Task Description</div>' +
                             '<div id="taskDescription" class="code-block"></div>';
      container.appendChild(taskSection);
      
      // Files to Modify
      const writeFilesSection = document.createElement('div');
      writeFilesSection.className = 'section';
      writeFilesSection.innerHTML = '<div class="section-title">Files to Modify</div>' +
                                   '<ul id="writeFilesList" class="file-list"></ul>';
      container.appendChild(writeFilesSection);
      
      // Trusty Agents
      const trustyAgentsSection = document.createElement('div');
      trustyAgentsSection.className = 'section';
      trustyAgentsSection.innerHTML = '<div class="section-title">Trusty Agents</div>' +
                                     '<div id="trustyAgentsSection">' +
                                     '<ul id="trustyAgentsList" class="file-list"></ul>' +
                                     '</div>';
      container.appendChild(trustyAgentsSection);
    }

    // Function to display protoblock data
    function displayProtoblockData(data) {
      console.log("Displaying protoblock data:", data);
      
      // Ensure protoblock display is visible
      toggleProtoblockDisplay(true);
      
      // Update header
      document.getElementById('protoblockAttempt').textContent = `Attempt ${data.attempt}`;
      
      // Update task description
      document.getElementById('taskDescription').textContent = data.task_description;
      
      // Update files to modify
      const writeFilesList = document.getElementById('writeFilesList');
      writeFilesList.innerHTML = '';
      data.write_files.forEach(file => {
        const li = document.createElement('li');
        // Create text node to ensure we can reference just the filename later
        li.appendChild(document.createTextNode(file));
        writeFilesList.appendChild(li);
      });
      
      // Update trusty agents
      const trustyAgentsList = document.getElementById('trustyAgentsList');
      trustyAgentsList.innerHTML = '';
      
      // Store trusty agent prompts data globally to access when popup is opened
      window.trustyAgentPrompts = data.trusty_agent_prompts || {};
      
      // Store trusty agent results data globally to access when popup is opened
      window.trustyAgentResults = data.trusty_agent_results || {};
      
      // Log trusty agent results for debugging
      console.log("Trusty agent prompts:", window.trustyAgentPrompts);
      console.log("Trusty agent results:", window.trustyAgentResults);
      console.log("Trusty agents:", data.trusty_agents);
      
      // Combined display logic for trusty agents and their prompts
      if (data.trusty_agents && data.trusty_agents.length > 0) {
        // Always show all agents in the list
        trustyAgentsList.style.display = 'block';
        data.trusty_agents.forEach(agent => {
          const li = document.createElement('li');
          li.textContent = agent;
          
          // Convert agent name to lowercase for matching with results
          // This ensures consistency with how the backend stores keys
          const agentKey = agent.toLowerCase().replace(/agent$/, '');
          
          // Log whether this agent has results
          const hasPrompt = window.trustyAgentPrompts[agent];
          const resultObj = window.trustyAgentResults && 
                        (window.trustyAgentResults[agent] || window.trustyAgentResults[agentKey]);
          const hasResults = resultObj && (resultObj.output || resultObj.image_url);
          
          console.log(`Agent ${agent} (key: ${agentKey}): has prompt: ${!!hasPrompt}, has results: ${!!hasResults}`, resultObj);
          
          // Always make the agent clickable if it has a prompt (even without results)
          li.classList.add('trusty-agent-item');
            
          // Add has-results class if agent has results
          if (hasResults) {
            li.classList.add('has-results');
            console.log(`Adding has-results class to ${agent}`);
          }
            
          li.addEventListener('click', () => {
            // Get the latest protoblock data for the agent
            const protoblock = {
              trusty_agent_prompts: window.trustyAgentPrompts || {},
              trusty_agent_results: window.trustyAgentResults || {}
            };
            displayTrustyAgentPrompt(agent, protoblock);
          });
          
          trustyAgentsList.appendChild(li);
        });
      } else {
        // No agents at all
        const li = document.createElement('li');
        li.textContent = 'No trusty agents specified';
        trustyAgentsList.appendChild(li);
      }
      
      // Check if we should attempt to make files clickable (only after success)
      const runtimeStatus = document.getElementById('runtimeStatus');
      const blockStatusTextContent = document.getElementById('blockStatusText')?.textContent || "";
      const isSuccess = blockStatusTextContent.includes("‚úÖ") || 
                       blockStatusTextContent.includes("successful") ||
                       blockStatusTextContent.includes("Ready");
      
      if (isSuccess) {
        // Make files clickable after a delay to ensure the DOM is ready
        setTimeout(makeFilesClickable, 300);
      }
    }

    // Update renderer and camera on resize for block panel
    window.addEventListener('resize', () => {
      const width = threeContainer.clientWidth;
      const height = threeContainer.clientHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });

    // Chat functionality in the chat panel
    const messageContainer = document.getElementById("messageContainer");
    const statusText = document.getElementById("statusText");
    const statusDot = document.querySelector("#recipientStatus .statusDot");
    const userInput = document.getElementById("userInput");
    const typingAnimation = document.getElementById("typingAnimation");
    const micButton = document.getElementById('micButton');
    const chatHeader = document.getElementById('chatHeader');

    function addChatMessage(sender, text) {
      const bubble = document.createElement("div");
      bubble.classList.add("chat-bubble");
      if (sender === "User") {
        bubble.classList.add("chat-user");
      } else if (sender === "AI") {
        bubble.classList.add("chat-ai");
      } else {
        // For System messages or others, no additional styling is applied.
      }
      bubble.textContent = text;
      messageContainer.appendChild(bubble);
      const clearDiv = document.createElement("div");
      clearDiv.classList.add("chat-clear");
      messageContainer.appendChild(clearDiv);
      messageContainer.scrollTop = messageContainer.scrollHeight;
    }

    function showTypingIndicator() {
      typingAnimation.style.display = "inline-flex";
    }

    function hideTypingIndicator() {
      typingAnimation.style.display = "none";
    }

    // Create WebSocket connection
    const socket = new WebSocket("ws://localhost:8765");

    // Connection opened
    socket.addEventListener('open', (event) => {
      console.log('Connected to WebSocket server');
      statusDot.style.backgroundColor = "#4caf50";
      statusText.textContent = "online";
      messageContainer.classList.remove("offline");
      chatHeader.classList.remove("offline");
    });
    
    // Handle WebSocket closure to indicate offline status (red indicator)
    socket.addEventListener('close', (event) => {
      console.log('WebSocket connection closed');
      statusDot.style.backgroundColor = "#f44336";
      statusText.textContent = "offline";
      messageContainer.classList.add("offline");
      chatHeader.classList.add("offline");
    });
    
    // Handle WebSocket errors to indicate offline status (red indicator)
    socket.addEventListener('error', (event) => {
      console.log('WebSocket error');
      statusDot.style.backgroundColor = "#f44336";
      statusText.textContent = "offline";
      messageContainer.classList.add("offline");
      chatHeader.classList.add("offline");
    });

    // Handle incoming messages from the WebSocket
    socket.onmessage = function(event) {
      let data;
      
      // Check if this is a component_mapping_update_result, forward to any iframe that might be listening
      try {
        data = JSON.parse(event.data);
        if (data.type === 'component_mapping_update_result') {
          window.postMessage(data, '*');
        }
      } catch (error) {
        // Not JSON, assume it's a chat message
        appendMessage(event.data, "assistant");
        return;
      }
      
      // Handle settings page content
      if (data.type === 'settings_page') {
        const settingsFrame = document.getElementById('settingsFrame');
        if (settingsFrame) {
          // Use srcdoc to set the content directly
          settingsFrame.srcdoc = data.html;
        }
        return;
      }
      
      // Handle status message updates
      if (data.type === 'status_message') {
        // Get status message for status bar display
        const statusMessage = data.message;
        
        // Show different status based on message content
        if (statusMessage.includes('‚ùå') || statusMessage.includes('Error')) {
          updateRecipientStatus(statusMessage, 'error');
          updateRuntimeStatus(statusMessage, 'error');
        } else if (statusMessage.includes('‚úÖ') || statusMessage.includes('success')) {
          updateRecipientStatus(statusMessage, 'success');
          updateRuntimeStatus(statusMessage, 'success');
        } else if (statusMessage.includes('Starting') || statusMessage.includes('Processing') || 
                   statusMessage.includes('Recording') || statusMessage.includes('Analyzing')) {
          updateRecipientStatus(statusMessage, 'processing');
          updateRuntimeStatus(statusMessage, 'processing');
        } else {
          updateRecipientStatus(statusMessage);
          updateRuntimeStatus(statusMessage);
        }
        
        // Check for attempt number updates in status messages - support both formats
        const attemptMatch = statusMessage.match(/Starting (?:block creation and execution )?attempt (\d+) of (\d+)/);
        if (attemptMatch) {
          const current = attemptMatch[1];
          const max = attemptMatch[2];
          // Update the attempt number display in protoblock header
          document.getElementById('protoblockAttempt').textContent = `Attempt ${current}/${max}`;
          console.log(`Updated attempt number to ${current}/${max}`);
        }
        
        // Check for block execution failure message
        if (statusMessage === "‚ùå Block execution failed!" || 
            statusMessage.startsWith("‚ùå Error:") ||
            statusMessage.includes("Error creating protoblock:") ||
            statusMessage.includes("Execution attempt") && statusMessage.includes("failed")) {
          console.log("Removing protoblock display due to failure message");
          // Force the canvas to be shown and protoblock to be hidden
          document.getElementById('protoblockContainer').style.display = 'none';
          document.querySelector('#blockPanel canvas').style.display = 'block';
        }
        
        // Show git operations panel after successful block execution
        if (statusMessage === "‚úÖ Block executed successfully! Displaying final results...") {
          console.log("Block successful, showing git operations panel");
          showGitOperationsPanel(true);
        }
        
        return;
      }
      
      // Handle other message types
      if (data.type === "error_message") {
        // Display prominent error message at the top of the right panel
        const errorMessage = document.getElementById("errorMessage");
        errorMessage.textContent = data.message;
        errorMessage.style.display = "block";
        
        errorMessage.classList.remove("animated");
        void errorMessage.offsetWidth;
        errorMessage.classList.add("animated");
        
        setTimeout(() => {
          errorMessage.style.display = "none";
        }, 30000);
        
        return;
      }
      else if (data.type === "info_message") {
        const infoMessage = document.getElementById("infoMessage");
        infoMessage.textContent = data.message;
        infoMessage.style.display = "block";
        
        setTimeout(() => {
          infoMessage.style.display = "none";
        }, 15000);
        
        return;
      }
      else if (data.type === "remove_protoblock") {
        console.log("Received explicit remove_protoblock message");
        document.getElementById('protoblockContainer').style.display = 'none';
        document.querySelector('#blockPanel canvas').style.display = 'block';
        
        document.getElementById('protoblockContainer').innerHTML = '';
        rebuildProtoblockContainer();
        
        // Update status
        updateRuntimeStatus(data.message || "Block processing complete");
        return;
      }
      else if (data.type === "protoblock_data") {
        console.log("Received protoblock data:", data);
        
        document.getElementById('protoblockContainer').style.display = 'block';
        document.querySelector('#blockPanel canvas').style.display = 'none';
        
        displayProtoblockData(data);
        
        console.log("Protoblock is now visible");
        return;
      }
      else if (data.type === "transcribed_message") {
        addChatMessage("User", data.message);
        
        const payload = {
          type: "user_message",
          message: data.message
        };
        socket.send(JSON.stringify(payload));
        showTypingIndicator();
        micButton.classList.remove('waiting');
        micButton.classList.remove('recording');
        micButton.classList.remove('rotating');
        micButton.classList.remove('transcribing');
        return;
      }
      else if (data.type === "file_status_response" || 
              data.type === "file_diff_response" || 
              data.type === "git_branch_response" || 
              data.type === "git_operation_response") {
        console.log(`Received ${data.type}`);
        return;
      }
      else if (data.type === "chat_message") {
        const role = data.role || "AI";
        const message = data.message || "";
        
        if (role === "user") {
          addChatMessage("User", message);
        } else if (role === "assistant") {
          addChatMessage("AI", message);
          hideTypingIndicator();
        } else {
          addChatMessage(role, message);
        }
        
        return;
      }
      else if (data.type === "recording_status") {
        // Handle recording status updates for microphone button
        console.log("Received recording status update:", data.is_recording);
        // Update the microphone button appearance based on recording status
        return;
      }
      else {
        // For unrecognized message types, just log instead of displaying in chat
        console.log("Received unknown message type:", data.type);
        console.warn("Unknown message data:", data);
        
        // Only display in chat if it explicitly has a role or appears to be a chat message
        if (data.role || (data.component_id === "chat_panel" && data.message)) {
          addChatMessage(data.role || "AI", data.message || JSON.stringify(data));
          hideTypingIndicator();
        }
      }
    };

    // Send user message when Enter key is pressed (without Shift)
    userInput.addEventListener("keydown", function(event) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        const text = userInput.value.trim();
        if (text !== "") {
          addChatMessage("User", text);
          
          const payload = {
            type: "user_message",
            message: text
          };
          
          socket.send(JSON.stringify(payload));
          showTypingIndicator();
          userInput.value = "";
        }
      }
    });

    // Bind click event to the block button for cube-like interaction
    const blockButton = document.getElementById('blockButton');
    blockButton.addEventListener('click', function() {
      updateRuntimeStatus("Executing protoblock...", "processing");
      toggleProtoblockDisplay(false);
      document.getElementById('protoblockContainer').innerHTML = '';
      rebuildProtoblockContainer();
      
      blockButton.classList.add('active');
      setTimeout(() => {
        blockButton.classList.remove('active');
      }, 300);
      
      const text = userInput.value.trim();
      if (text !== "") {
        addChatMessage("User", text);
        const messagePayload = {
          type: "user_message",
          message: text
        };
        socket.send(JSON.stringify(messagePayload));
        showTypingIndicator();
        userInput.value = "";
      }
      
      const payload = {
        type: "block_click"
      };
      socket.send(JSON.stringify(payload));
    });

    // Bind click event to the microphone button to send the 'mic_click' event to the backend
    let isRecording = false; // flag to track recording state

    micButton.addEventListener('click', function() {
      isRecording = !isRecording;
      if (isRecording) {
        micButton.classList.add('recording');
        micButton.classList.remove('rotating');
        micButton.classList.remove('transcribing');
      } else {
        micButton.classList.remove('recording');
        micButton.classList.remove('rotating');
        micButton.classList.add('transcribing');
      }
      const payload = {
        type: "mic_click",
        recording: isRecording
      };
      socket.send(JSON.stringify(payload));
    });

    // Initialize Three.js scene for the rotating cube inside the block button
    const btnCanvas = document.getElementById('cubeCanvas');
    const btnRenderer = new THREE.WebGLRenderer({ canvas: btnCanvas, antialias: true, alpha: true });
    btnRenderer.setPixelRatio(window.devicePixelRatio);
    btnRenderer.setClearColor(0x000000, 0);
    btnRenderer.setSize(32, 32);

    const btnScene = new THREE.Scene();
    const btnCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    btnCamera.position.z = 2;

    const btnGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
    const btnMaterial = new THREE.MeshPhongMaterial({ 
      color: 0x0078d7, 
      shininess: 100, 
      wireframe: true, 
      transparent: true, 
      opacity: 0.7,
      emissive: 0x0078d7, 
      emissiveIntensity: 0.5
    });
    const btnCube = new THREE.Mesh(btnGeometry, btnMaterial);
    btnScene.add(btnCube);

    const btnAmbient = new THREE.AmbientLight(0xffffff, 0.8);
    btnScene.add(btnAmbient);

    function animateBtnCube() {
      requestAnimationFrame(animateBtnCube);
      btnCube.rotation.x += 0.02;
      btnCube.rotation.y += 0.02;
      btnRenderer.render(btnScene, btnCamera);
    }
    animateBtnCube();

    // Initially hide the protoblock display
    toggleProtoblockDisplay(false);
    rebuildProtoblockContainer();

    // Settings button click handler
    document.getElementById('settingsButton').addEventListener('click', function () {
      // Create a settings iframe
      let settingsFrame = document.getElementById('settingsFrame');
      if (!settingsFrame) {
        settingsFrame = document.createElement('iframe');
        settingsFrame.id = 'settingsFrame';
        settingsFrame.style.width = '100%';
        settingsFrame.style.height = '100%';
        settingsFrame.style.border = 'none';
        
        // Clear the block panel and add the iframe
        const blockPanel = document.getElementById('blockPanel');
        // Hide the 3D scene temporarily
        renderer.domElement.style.display = 'none';
        
        // Hide the protoblock container if it exists
        const protoblockContainer = document.getElementById('protoblockContainer');
        if (protoblockContainer) {
          protoblockContainer.style.display = 'none';
        }
        
        blockPanel.appendChild(settingsFrame);
        
        // Add a close button
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close Settings';
        closeBtn.style.position = 'absolute';
        closeBtn.style.top = '10px';
        closeBtn.style.right = '10px';
        closeBtn.style.padding = '5px 10px';
        closeBtn.style.background = '#f44336';
        closeBtn.style.color = 'white';
        closeBtn.style.border = 'none';
        closeBtn.style.borderRadius = '4px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.style.zIndex = '1000';
        
        closeBtn.addEventListener('click', function() {
          // Remove the iframe and close button
          if (settingsFrame) blockPanel.removeChild(settingsFrame);
          blockPanel.removeChild(closeBtn);
          
          // Show the 3D scene again
          renderer.domElement.style.display = 'block';
          
          // Update block title and status
          document.getElementById('blockTitle').textContent = 'Block Status';
          updateRuntimeStatus('Ready...');
        });
        
        blockPanel.appendChild(closeBtn);
      }
      
      // Update block panel header
      document.getElementById('blockTitle').textContent = 'Settings';
      updateRuntimeStatus('Configuring settings...');
      
      // Request settings content via websocket
      socket.send(JSON.stringify({ type: "settings_click" }));
    });
    
    // Listen for messages from iframes (for settings page)
    window.addEventListener('message', function(event) {
      // Check if this is a websocket message request from the settings iframe
      if (event.data && event.data.type === 'settings_websocket_message' && event.data.data) {
        // Forward the message data to the websocket
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify(event.data.data));
        } else {
          console.error('WebSocket is not open, cannot send settings update');
          
          // Reply with an error message
          event.source.postMessage({
            type: 'component_mapping_update_result',
            success: false,
            error: 'WebSocket is not connected'
          }, '*');
        }
      }
    });
  </script>
  
  <!-- File diff overlay -->
  <div id="fileDiffOverlay">
    <div id="fileDiffContent">
      <div id="fileDiffHeader">
        <h3 id="fileDiffTitle">File Changes</h3>
        <div>
          <button id="fileDiffViewToggle" title="Toggle between unified and split view">Split View</button>
          <button id="fileDiffCloseBtn">√ó</button>
        </div>
      </div>
      <div id="fileDiffBody"></div>
      <div id="fileDiffSplitView" class="initially-hidden">
        <div id="fileDiffLeft"></div>
        <div id="fileDiffRight"></div>
        <div id="fileDiffScrollContainer">
          <div id="fileDiffScrollContent"></div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Trusty Agent Prompt overlay -->
  <div id="trustyAgentOverlay">
    <div id="trustyAgentContent">
      <div id="trustyAgentHeader">
        <h3 id="trustyAgentTitle">Trusty Agent</h3>
        <button id="trustyAgentCloseBtn">√ó</button>
      </div>
      <div id="trustyAgentBody">
        <div class="trusty-agent-section">
          <div class="trusty-agent-section-title">Prompt</div>
          <div id="trustyAgentPromptText" class="code-block"></div>
        </div>
        <div class="trusty-agent-section initially-hidden" id="trustyAgentResultSection">
          <div class="trusty-agent-section-title">Result</div>
          <div id="trustyAgentResultStatus" class="agent-status"></div>
          <div id="trustyAgentAgentType" class="agent-type"></div>
          <div id="trustyAgentResultText" class="code-block"></div>
        </div>
        <div class="trusty-agent-section initially-hidden" id="trustyAgentPlausibilitySection">
          <div class="trusty-agent-section-title">Plausibility Evaluation</div>
          <div class="plausibility-container">
            <div class="plausibility-grade-container">
              <div id="trustyAgentGrade" class="grade"></div>
              <div id="trustyAgentGradeInfo" class="grade-info"></div>
            </div>
            <div id="trustyAgentVerificationInfo" class="verification-info"></div>
          </div>
        </div>
        <div class="trusty-agent-section initially-hidden" id="trustyAgentImageSection">
          <div class="trusty-agent-section-title">Screenshot</div>
          <div id="trustyAgentImageContainer">
            <div id="mainImageContainer" style="text-align: center; width: 100%;">
              <img id="trustyAgentImage" alt="ThreeJS Before/After Comparison" class="constrained-image" style="max-width: 90%; height: auto; border: 1px solid #ccc;">
            </div>
            <div id="comparisonImageContainer" class="initially-hidden">
              <img id="trustyAgentComparisonImage" alt="Comparison Screenshot" class="constrained-image">
            </div>
          </div>
        </div>
        <div class="trusty-agent-section initially-hidden" id="trustyAgentTestResultsSection">
          <div class="trusty-agent-section-title">Test Results</div>
          <div id="trustyAgentTestResults" class="code-block"></div>
        </div>
        <div class="trusty-agent-section initially-hidden" id="trustyAgentSummarySection">
          <div class="trusty-agent-section-title">Summary</div>
          <div id="trustyAgentSummary" class="summary-block"></div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // File diff handling
    const fileDiffOverlay = document.getElementById('fileDiffOverlay');
    const fileDiffCloseBtn = document.getElementById('fileDiffCloseBtn');
    const fileDiffBody = document.getElementById('fileDiffBody');
    const fileDiffTitle = document.getElementById('fileDiffTitle');
    const fileDiffSplitView = document.getElementById('fileDiffSplitView');
    const fileDiffLeft = document.getElementById('fileDiffLeft');
    const fileDiffRight = document.getElementById('fileDiffRight');
    const fileDiffViewToggle = document.getElementById('fileDiffViewToggle');

    let diffViewMode = 'unified'; // 'unified' or 'split'

    // Toggle between unified and split view
    fileDiffViewToggle.addEventListener('click', () => {
      if (diffViewMode === 'unified') {
        diffViewMode = 'split';
        fileDiffBody.style.display = 'none';
        fileDiffSplitView.style.display = 'flex';
        fileDiffViewToggle.textContent = 'Unified View';
        setupSplitViewScrolling();
      } else {
        diffViewMode = 'unified';
        fileDiffBody.style.display = 'block';
        fileDiffSplitView.style.display = 'none';
        fileDiffViewToggle.textContent = 'Split View';
      }
    });
    
    function setupSplitViewScrolling() {
      const scrollContainer = document.getElementById('fileDiffScrollContainer');
      const scrollContent = document.getElementById('fileDiffScrollContent');
      const leftPane = document.getElementById('fileDiffLeft');
      const rightPane = document.getElementById('fileDiffRight');
      
      if (window.currentDiffLineCount) {
        scrollContent.style.height = (window.currentDiffLineCount * 22) + 'px';
      }
      
      scrollContainer.onscroll = function() {
        leftPane.scrollTop = scrollContainer.scrollTop;
        rightPane.scrollTop = scrollContainer.scrollTop;
      };
    }

    function parseDiffForSplitView(diff) {
      const leftContent = [];
      const rightContent = [];
      
      const fileHeaderRegex = /^diff --git a\/(.*) b\/(.*)$/;
      const hunkHeaderRegex = /^@@ -(\d+),(\d+) \+(\d+),(\d+) @@(.*)$/;
      
      let leftLineNumber = 1;
      let rightLineNumber = 1;
      let currentFile = '';
      let inHunk = false;
      let diffLineCount = 0;
      
      leftContent.push('<div class="diff-file-header">Original</div>');
      rightContent.push('<div class="diff-file-header">Modified</div>');
      diffLineCount++;
      
      const lines = diff.split('\n');
      lines.forEach(line => {
        const fileHeaderMatch = line.match(fileHeaderRegex);
        if (fileHeaderMatch) {
          currentFile = fileHeaderMatch[1];
          leftContent.push(`<div class="diff-section-header">${currentFile}</div>`);
          rightContent.push(`<div class="diff-section-header">${currentFile}</div>`);
          diffLineCount++;
          return;
        }
        
        const hunkHeaderMatch = line.match(hunkHeaderRegex);
        if (hunkHeaderMatch) {
          const leftStart = parseInt(hunkHeaderMatch[1]);
          const rightStart = parseInt(hunkHeaderMatch[3]);
          
          inHunk = true;
          leftLineNumber = leftStart;
          rightLineNumber = rightStart;
          
          leftContent.push(`<div class="diff-section-header">${line}</div>`);
          rightContent.push(`<div class="diff-section-header">${line}</div>`);
          diffLineCount++;
          return;
        }
        
        if (line.startsWith('---') || line.startsWith('+++') || line.startsWith('index ')) {
          return;
        }
        
        if (inHunk) {
          if (line.startsWith('-')) {
            leftContent.push(`
              <div class="diff-line diff-removed-line">
                <span class="diff-line-number">${leftLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            rightContent.push(`<div class="diff-line diff-filler"></div>`);
            leftLineNumber++;
            diffLineCount++;
          } else if (line.startsWith('+')) {
            leftContent.push(`<div class="diff-line diff-filler"></div>`);
            rightContent.push(`
              <div class="diff-line diff-added-line">
                <span class="diff-line-number">${rightLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            rightLineNumber++;
            diffLineCount++;
          } else if (line.startsWith(' ')) {
            leftContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${leftLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            rightContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${rightLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            leftLineNumber++;
            rightLineNumber++;
            diffLineCount++;
          } else if (line.trim() === '') {
            leftContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${leftLineNumber}</span>
                <span class="diff-line-content"></span>
              </div>
            `);
            rightContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${rightLineNumber}</span>
                <span class="diff-line-content"></span>
              </div>
            `);
            leftLineNumber++;
            rightLineNumber++;
            diffLineCount++;
          }
        }
      });
      
      return {
        left: leftContent.join(''),
        right: rightContent.join(''),
        lineCount: diffLineCount
      };
    }

    function escapeHtml(unsafe) {
      return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
    }

    fileDiffCloseBtn.addEventListener('click', () => {
      fileDiffOverlay.style.display = 'none';
    });

    fileDiffOverlay.addEventListener('click', (event) => {
      if (event.target === fileDiffOverlay) {
        fileDiffOverlay.style.display = 'none';
      }
    });

    async function showFileDiff(filename) {
      fileDiffTitle.textContent = `Changes in ${filename}`;
      fileDiffBody.innerHTML = 'Loading diff...';
      fileDiffLeft.innerHTML = 'Loading...';
      fileDiffRight.innerHTML = 'Loading...';
      fileDiffOverlay.style.display = 'flex';
      
      requestFileDiff(filename);
    }
  </script>
  
  <!-- Trusty Agent Prompt overlay functionality -->
  <script>
    const trustyAgentOverlay = document.getElementById('trustyAgentOverlay');
    const trustyAgentCloseBtn = document.getElementById('trustyAgentCloseBtn');
    const trustyAgentBody = document.getElementById('trustyAgentBody');
    const trustyAgentTitle = document.getElementById('trustyAgentTitle');

    function showTrustyAgentPrompt(agentName, agentKey) {
      console.log(`Showing prompt for agent: ${agentName} (key: ${agentKey})`);
      
      trustyAgentTitle.textContent = `${agentName}`;
      
      const prompt = window.trustyAgentPrompts[agentName] || '';
      console.log(`Prompt for ${agentName}:`, prompt ? 'exists' : 'not found');
      
      const results = window.trustyAgentResults && 
                     (window.trustyAgentResults[agentName] || window.trustyAgentResults[agentKey] || null);
      
      console.log(`Results for ${agentName}:`, results || 'not found');
      
      const promptTextElement = document.getElementById('trustyAgentPromptText');
      promptTextElement.textContent = prompt || 'No prompt available for this agent.';
      
      const resultSection = document.getElementById('trustyAgentResultSection');
      const resultTextElement = document.getElementById('trustyAgentResultText');
      const resultStatusElement = document.getElementById('trustyAgentResultStatus');
      const imageSection = document.getElementById('trustyAgentImageSection');
      const imageElement = document.getElementById('trustyAgentImage');
      
      const blockStatusText = document.getElementById('blockStatusText');
      const executionSuccessful = blockStatusText.textContent.includes("‚úÖ");
      
      if (results && (results.output || results.image_url)) {
        console.log(`${agentName} has results to display`);
        
        if (results.output) {
          console.log(`${agentName} output:`, results.output);
          resultSection.style.display = 'block';
          resultTextElement.textContent = results.output;
          
          if (results.status) {
            resultStatusElement.className = 'agent-status ' + results.status;
            let statusText = '';
            switch (results.status) {
              case 'passed':
                statusText = 'Verification Passed ‚úÖ';
                break;
              case 'failed':
                statusText = 'Verification Failed ‚ùå';
                break;
              case 'error':
                statusText = 'Execution Error ‚ö†Ô∏è';
                break;
              default:
                statusText = results.status;
            }
            resultStatusElement.textContent = statusText;
            resultStatusElement.style.display = 'inline-block';
          } else {
            resultStatusElement.style.display = 'none';
          }
        } else {
          resultSection.style.display = 'none';
        }
        
        if (results.image_url) {
          console.log(`${agentName} image URL:`, results.image_url);
          imageSection.style.display = 'block';
          imageElement.src = makePathUsable(results.image_url);
        } else if (results.comparison_path) {
          // Explicitly handle comparison_path that may not be exposed as image_url
          console.log(`${agentName} comparison path:`, results.comparison_path);
          imageSection.style.display = 'block';
          imageElement.src = makePathUsable(results.comparison_path);
        } else {
          imageSection.style.display = 'none';
        }
      } else {
        console.log(`${agentName} has no results to display`);
        
        resultSection.style.display = 'block';
        resultStatusElement.style.display = 'none';
        if (executionSuccessful) {
          resultTextElement.innerHTML = '<div class="diff-empty">This agent was executed but did not produce any output.</div>';
        } else {
          resultTextElement.innerHTML = '<div class="diff-empty">No results available yet for this agent.</div>';
        }
        imageSection.style.display = 'none';
      }
      
      trustyAgentOverlay.style.display = 'flex';
    }

    trustyAgentCloseBtn.addEventListener('click', () => {
      trustyAgentOverlay.style.display = 'none';
    });

    trustyAgentOverlay.addEventListener('click', (event) => {
      if (event.target === trustyAgentOverlay) {
        trustyAgentOverlay.style.display = 'none';
      }
    });

    function displayTrustyAgentPrompt(agentName, protoblock) {
      console.log("Displaying prompt for agent:", agentName);
      const trustyAgentOverlay = document.getElementById('trustyAgentOverlay');
      const trustyAgentTitle = document.getElementById('trustyAgentTitle');
      const trustyAgentPromptText = document.getElementById('trustyAgentPromptText');
      const trustyAgentResultSection = document.getElementById('trustyAgentResultSection');
      const trustyAgentResultText = document.getElementById('trustyAgentResultText');
      const trustyAgentImageSection = document.getElementById('trustyAgentImageSection');
      const trustyAgentImage = document.getElementById('trustyAgentImage');
      const trustyAgentAgentType = document.getElementById('trustyAgentAgentType');
      const trustyAgentResultStatus = document.getElementById('trustyAgentResultStatus');
      const trustyAgentComparisonImage = document.getElementById('trustyAgentComparisonImage');
      const comparisonImageContainer = document.getElementById('comparisonImageContainer');
      const trustyAgentTestResultsSection = document.getElementById('trustyAgentTestResultsSection');
      const trustyAgentTestResults = document.getElementById('trustyAgentTestResults');
      const trustyAgentSummarySection = document.getElementById('trustyAgentSummarySection');
      const trustyAgentSummary = document.getElementById('trustyAgentSummary');
      const trustyAgentPlausibilitySection = document.getElementById('trustyAgentPlausibilitySection');
      const trustyAgentGrade = document.getElementById('trustyAgentGrade');
      const trustyAgentGradeInfo = document.getElementById('trustyAgentGradeInfo');
      const trustyAgentVerificationInfo = document.getElementById('trustyAgentVerificationInfo');

      trustyAgentOverlay.style.display = 'flex';

      trustyAgentTitle.textContent = `Trusty Agent: ${agentName}`;

      const agentKey = agentName.toLowerCase();
      let agentPrompt = "";

      let hasPrompt = false;
      if (protoblock.trusty_agent_prompts && protoblock.trusty_agent_prompts[agentKey]) {
        hasPrompt = true;
        agentPrompt = protoblock.trusty_agent_prompts[agentKey];
      }

      trustyAgentPromptText.textContent = hasPrompt ? agentPrompt : "No prompt found for this agent.";

      let resultObj = null;
      let hasResults = false;
      
      if (protoblock.trusty_agent_results) {
        console.log("Available trusty agent results:", Object.keys(protoblock.trusty_agent_results));
        const possibleKeys = [agentName, agentKey, agentName.toLowerCase(), agentKey.replace('agent', '')];
        for (const key of possibleKeys) {
          if (protoblock.trusty_agent_results[key]) {
            resultObj = protoblock.trusty_agent_results[key];
            hasResults = (resultObj.output !== undefined || resultObj.image_url !== undefined);
            console.log(`Found results for ${agentKey} using key '${key}':`, resultObj);
            // Debug - log the detailed object contents to check for image paths
            console.log(`Result object for ${agentKey} - JSON:`, JSON.stringify(resultObj, null, 2));
            break;
          }
        }
      }
      
      function makePathUsable(path) {
        if (!path) return null;
        if (path.startsWith('http') || path.startsWith('data:') || path.startsWith('./') || path.startsWith('/')) {
          return path;
        }
        try {
          return 'file://' + path;
        } catch (e) {
          console.error('Error processing path:', e);
          return path;
        }
      }

      trustyAgentResultSection.style.display = 'none';
      trustyAgentImageSection.style.display = 'none';
      trustyAgentTestResultsSection.style.display = 'none';
      trustyAgentSummarySection.style.display = 'none';
      trustyAgentPlausibilitySection.style.display = 'none';

      // Check execution status by looking at blockStatusText
      const blockStatusText = document.getElementById('blockStatusText');
      const executionSuccessful = blockStatusText.textContent.includes("‚úÖ");

      if (hasResults && resultObj) {
        if (resultObj.output) {
          trustyAgentResultSection.style.display = 'block';
          if (resultObj.status) {
            trustyAgentResultStatus.textContent = resultObj.status;
            trustyAgentResultStatus.className = 'agent-status';
            if (resultObj.status.toLowerCase() === 'passed') {
              trustyAgentResultStatus.classList.add('passed');
            } else if (resultObj.status.toLowerCase() === 'failed') {
              trustyAgentResultStatus.classList.add('failed');
            } else {
              trustyAgentResultStatus.classList.add('error');
            }
          } else {
            trustyAgentResultStatus.textContent = '';
            trustyAgentResultStatus.className = 'agent-status';
          }
          trustyAgentResultText.textContent = resultObj.output || "No text output available";
        }
        if (resultObj.image_url) {
          trustyAgentImageSection.style.display = 'block';
          const usablePath = makePathUsable(resultObj.image_url);
          trustyAgentImage.src = usablePath;
          console.log(`Setting main image src to: ${usablePath}`);
        } else if (resultObj.comparison_path) {
          // Explicitly handle comparison_path that may not be exposed as image_url
          trustyAgentImageSection.style.display = 'block';
          const usablePath = makePathUsable(resultObj.comparison_path);
          trustyAgentImage.src = usablePath;
          console.log(`Setting main image src from comparison_path: ${usablePath}`);
        } else {
          trustyAgentImageSection.style.display = 'none';
        }
        
        // Always hide the comparison container - we only need one image
        comparisonImageContainer.style.display = 'none';
      } else {
        trustyAgentResultSection.style.display = 'block';
        trustyAgentResultStatus.style.display = 'none';
        trustyAgentAgentType.style.display = 'none';
        trustyAgentResultText.textContent = "No results found for this agent.";
        console.log(`No results found for agent: ${agentKey}`);
      }

      const trustyAgentCloseBtn = document.getElementById('trustyAgentCloseBtn');
      trustyAgentCloseBtn.onclick = function() {
        trustyAgentOverlay.style.display = 'none';
      };
    }
  </script>
  
  <script>
    // File diff view toggle and helper functions already defined above
  </script>
  
  <!-- New settings page functionality -->
  <script>
    // Removed previous placeholder implementation.
    // The settings button now sends a WebSocket message ("settings_click")
    // which is handled by the UIManager on the backend to generate settings HTML via get_config_html.
  </script>
</body>
</html>