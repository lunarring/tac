<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>tac.vibe</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="index.css">
</head>
<body>
  <div id="splitContainer">
    <div id="chatPanel">
      <div id="chatHeader">
        <div id="recipientName">tac.vibe</div>
        <div id="typingAnimation">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </div>
        <div id="recipientStatus">
          <span class="statusDot"></span>
          <span id="statusText">connecting...</span>
        </div>
      </div>
      <div id="messageContainer"></div>
      <div id="gitOperationsPanel" class="initially-hidden">
        <div class="section-title">Git Operations</div>
        <div class="git-buttons">
          <button id="commitChangesBtn" class="git-button">Commit Changes</button>
          <button id="discardChangesBtn" class="git-button">Discard Changes</button>
          <div class="merge-container">
            <button id="mergeBtn" class="git-button">Merge with Branch</button>
            <select id="branchSelect" class="branch-select">
              <option value="">Select Branch</option>
            </select>
          </div>
        </div>
      </div>
      <div id="inputContainer">
        <textarea id="userInput" placeholder="Type your message here..." rows="2"></textarea>
        <div id="buttonContainer">
          <div id="micButton" class="action-button">🎤</div>
          <div id="blockButton" class="action-button">
            <canvas id="cubeCanvas" width="32" height="32"></canvas>
          </div>
        </div>
      </div>
    </div>
    <div id="blockPanel">
      <div id="blockHeader">
        <div id="blockTitle">Block Status</div>
        <div id="blockStatus">
          <span class="statusDot blockStatusDot"></span>
          <span id="blockStatusText">Ready...</span>
        </div>
      </div>
      <div id="errorMessage"></div>
      <div id="infoMessage"></div>
      <div id="protoblockContainer">
        <!-- Protoblock container structure -->
        <div id="protoblockHeader">
          <h2>Protoblock</h2>
          <p id="protoblockAttempt">Attempt 1/4</p>
        </div>
        <div class="section">
          <div class="section-title">Task Description</div>
          <div id="taskDescription" class="code-block"></div>
        </div>
        <div class="section">
          <div class="section-title">Files to Modify</div>
          <ul id="writeFilesList" class="file-list"></ul>
        </div>
        <div class="section">
          <div class="section-title">Trusty Agents</div>
          <div id="trustyAgentsSection">
            <ul id="trustyAgentsList" class="file-list"></ul>
            
          </div>
        </div>
      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    // Utility functions for showing and hiding elements
    function hideElement(element) {
      if (typeof element === 'string') {
        element = document.getElementById(element) || document.querySelector(element);
      }
      if (element) {
        // Just set display to none for consistency with existing code
        element.style.display = 'none';
        
        // Also update classes for future use
        element.classList.add('hidden');
        element.classList.remove('visible');
        element.classList.remove('display-flex');
      }
    }
    
    function showElement(element, displayType = 'block') {
      if (typeof element === 'string') {
        element = document.getElementById(element) || document.querySelector(element);
      }
      if (element) {
        // Set the display style directly for compatibility with existing code
        element.style.display = displayType;
        
        // Also update classes for future use
        element.classList.remove('hidden');
        if (displayType === 'flex') {
          element.classList.add('display-flex');
        } else {
          element.classList.add('visible');
        }
      }
    }
    
    function toggleElement(element, displayType = 'block') {
      if (typeof element === 'string') {
        element = document.getElementById(element) || document.querySelector(element);
      }
      if (element) {
        if (element.style.display === 'none' || getComputedStyle(element).display === 'none') {
          showElement(element, displayType);
        } else {
          hideElement(element);
        }
      }
    }

    // Initialize Three.js scene in the block panel
    const threeContainer = document.getElementById('blockPanel');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, threeContainer.clientWidth / threeContainer.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(threeContainer.clientWidth, threeContainer.clientHeight);
    renderer.setClearColor(0xe0eafc, 1);
    threeContainer.appendChild(renderer.domElement);

    // Create a polished cube with a refined material configured with wireframe: true
    const geometry = new THREE.BoxGeometry();
    const cubeMaterial = new THREE.MeshPhongMaterial({ 
      color: 0x0078d7, 
      shininess: 100, 
      wireframe: true, 
      transparent: true, 
      opacity: 0.7,
      emissive: 0x0078d7,
      emissiveIntensity: 0.5
    });
    const cube = new THREE.Mesh(geometry, cubeMaterial);
    // Center the cube horizontally within the scene
    cube.position.x = 0;
    scene.add(cube);

    // Add a wireframe overlay using EdgesGeometry and LineSegments for added style
    const edges = new THREE.EdgesGeometry(geometry);
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
    const wireframe = new THREE.LineSegments(edges, lineMaterial);
    cube.add(wireframe);

    // Position the camera and add lights for a refined look
    camera.position.set(3, 3, 5);
    camera.lookAt(0, 0, 0);
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    function animate() {
      requestAnimationFrame(animate);
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;
      renderer.render(scene, camera);
    }
    animate();

    // Function to toggle between 3D cube and protoblock display
    function toggleProtoblockDisplay(show) {
      const protoblockContainer = document.getElementById('protoblockContainer');
      const canvas = renderer.domElement;
      const runtimeStatus = document.getElementById('runtimeStatus');
      
      if (show) {
        // First show the protoblock container
        showElement(protoblockContainer);
        
        // Use a smooth transition for the canvas
        canvas.style.opacity = '0';
        setTimeout(() => {
          hideElement(canvas);
          // Ensure the status is properly visible over the protoblock
          runtimeStatus.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
          document.getElementById('blockHeader').style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
        }, 300);
      } else {
        // Show the canvas first
        showElement(canvas);
        setTimeout(() => {
          canvas.style.opacity = '1';
          // Hide the protoblock container
          hideElement(protoblockContainer);
          // Reset status background for cube view
          runtimeStatus.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
          document.getElementById('blockHeader').style.backgroundColor = 'transparent';
          document.getElementById('blockHeader').style.boxShadow = 'none';
        }, 50);
      }
    }

    // Function to update the runtime status with appropriate styling
    function updateRuntimeStatus(message, status = "default") {
      const statusTextElement = document.getElementById("blockStatusText");
      const statusDotElement = document.querySelector("#blockStatus .blockStatusDot");
      
      if (!statusTextElement || !statusDotElement) return;
      
      statusTextElement.textContent = message;
      
      // Remove all status classes from text and dot
      statusTextElement.classList.remove("processing", "success", "error", "default");
      statusDotElement.classList.remove("processing", "success", "error", "default", "online", "offline");
      
      // Add appropriate class based on status
      if (status === "processing") {
        statusTextElement.classList.add("processing");
        statusDotElement.classList.add("processing"); // Yellow dot for processing
      } else if (status === "success") {
        statusTextElement.classList.add("success");
        statusDotElement.classList.add("success"); // Green dot for success
      } else if (status === "error") {
        statusTextElement.classList.add("error");
        statusDotElement.classList.add("error"); // Red dot for error
      } else {
        statusTextElement.classList.add("default");
        statusDotElement.classList.add("online"); // Default to green/online dot
      }
    }
    
    // Function to handle block execution failure
    function handleBlockFailure() {
      // Hide the protoblock display completely
      toggleProtoblockDisplay(false);
      
      // Reset any protoblock data displayed
      document.getElementById('protoblockContainer').innerHTML = '';
      
      // Rebuild the container structure
      rebuildProtoblockContainer();
      
      // Update the runtime status to show error
      updateRuntimeStatus("Block execution failed", "error");
    }
    
    // Function to rebuild the empty protoblock container structure
    function rebuildProtoblockContainer() {
      const container = document.getElementById('protoblockContainer');
      
      // Clear the container first
      container.innerHTML = '';
      
      // Header
      const header = document.createElement('div');
      header.id = 'protoblockHeader';
      header.innerHTML = '<h2>Protoblock</h2>' +
                         '<p id="protoblockAttempt">Attempt 1/4</p>';
      container.appendChild(header);
      
      // Task Description
      const taskSection = document.createElement('div');
      taskSection.className = 'section';
      taskSection.innerHTML = '<div class="section-title">Task Description</div>' +
                             '<div id="taskDescription" class="code-block"></div>';
      container.appendChild(taskSection);
      
      // Files to Modify
      const writeFilesSection = document.createElement('div');
      writeFilesSection.className = 'section';
      writeFilesSection.innerHTML = '<div class="section-title">Files to Modify</div>' +
                                   '<ul id="writeFilesList" class="file-list"></ul>';
      container.appendChild(writeFilesSection);
      
      // Trusty Agents
      const trustyAgentsSection = document.createElement('div');
      trustyAgentsSection.className = 'section';
      trustyAgentsSection.innerHTML = '<div class="section-title">Trusty Agents</div>' +
                                     '<div id="trustyAgentsSection">' +
                                     '<ul id="trustyAgentsList" class="file-list"></ul>' +
                                     '</div>';
      container.appendChild(trustyAgentsSection);
    }

    // Function to display protoblock data
    function displayProtoblockData(data) {
      console.log("Displaying protoblock data:", data);
      
      // Ensure protoblock display is visible
      toggleProtoblockDisplay(true);
      
      // Update header
      document.getElementById('protoblockAttempt').textContent = `Attempt ${data.attempt}`;
      
      // Update task description
      document.getElementById('taskDescription').textContent = data.task_description;
      
      // Update files to modify
      const writeFilesList = document.getElementById('writeFilesList');
      writeFilesList.innerHTML = '';
      data.write_files.forEach(file => {
        const li = document.createElement('li');
        // Create text node to ensure we can reference just the filename later
        li.appendChild(document.createTextNode(file));
        writeFilesList.appendChild(li);
      });
      
      // Update trusty agents
      const trustyAgentsList = document.getElementById('trustyAgentsList');
      trustyAgentsList.innerHTML = '';
      
      // Store trusty agent prompts data globally to access when popup is opened
      window.trustyAgentPrompts = data.trusty_agent_prompts || {};
      
      // Store trusty agent results data globally to access when popup is opened
      window.trustyAgentResults = data.trusty_agent_results || {};
      
      // Log trusty agent results for debugging
      console.log("Trusty agent prompts:", window.trustyAgentPrompts);
      console.log("Trusty agent results:", window.trustyAgentResults);
      console.log("Trusty agents:", data.trusty_agents);
      
      // Combined display logic for trusty agents and their prompts
      if (data.trusty_agents && data.trusty_agents.length > 0) {
        // Always show all agents in the list
        trustyAgentsList.style.display = 'block';
        data.trusty_agents.forEach(agent => {
          const li = document.createElement('li');
          li.textContent = agent;
          
          // Convert agent name to lowercase for matching with results
          // This ensures consistency with how the backend stores keys
          const agentKey = agent.toLowerCase().replace(/agent$/, '');
          
          // Log whether this agent has results
          const hasPrompt = window.trustyAgentPrompts[agent];
          const resultObj = window.trustyAgentResults && 
                        (window.trustyAgentResults[agent] || window.trustyAgentResults[agentKey]);
          const hasResults = resultObj && (resultObj.output || resultObj.image_url);
          
          console.log(`Agent ${agent} (key: ${agentKey}): has prompt: ${!!hasPrompt}, has results: ${!!hasResults}`, resultObj);
          
          // Always make the agent clickable if it has a prompt (even without results)
          li.classList.add('trusty-agent-item');
            
          // Add has-results class if agent has results
          if (hasResults) {
            li.classList.add('has-results');
            console.log(`Adding has-results class to ${agent}`);
          }
            
          li.addEventListener('click', () => {
            // Get the latest protoblock data for the agent
            const protoblock = {
              trusty_agent_prompts: window.trustyAgentPrompts || {},
              trusty_agent_results: window.trustyAgentResults || {}
            };
            displayTrustyAgentPrompt(agent, protoblock);
          });
          
          trustyAgentsList.appendChild(li);
        });
      } else {
        // No agents at all
        const li = document.createElement('li');
        li.textContent = 'No trusty agents specified';
        trustyAgentsList.appendChild(li);
      }
      
      // Check if we should attempt to make files clickable (only after success)
      const runtimeStatus = document.getElementById('runtimeStatus');
      const blockStatusTextContent = document.getElementById('blockStatusText')?.textContent || "";
      const isSuccess = blockStatusTextContent.includes("✅") || 
                       blockStatusTextContent.includes("successful") ||
                       blockStatusTextContent.includes("Ready");
      
      if (isSuccess) {
        // Make files clickable after a delay to ensure the DOM is ready
        setTimeout(makeFilesClickable, 300);
      }
    }

    // Update renderer and camera on resize for block panel
    window.addEventListener('resize', () => {
      const width = threeContainer.clientWidth;
      const height = threeContainer.clientHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });

    // Chat functionality in the chat panel
    const messageContainer = document.getElementById("messageContainer");
    const statusText = document.getElementById("statusText");
    const statusDot = document.querySelector("#recipientStatus .statusDot");
    const userInput = document.getElementById("userInput");
    const typingAnimation = document.getElementById("typingAnimation");
    const micButton = document.getElementById('micButton');
    const chatHeader = document.getElementById('chatHeader');

    function addChatMessage(sender, text) {
      const bubble = document.createElement("div");
      bubble.classList.add("chat-bubble");
      if (sender === "User") {
        bubble.classList.add("chat-user");
      } else if (sender === "AI") {
        bubble.classList.add("chat-ai");
      } else {
        // For System messages or others, no additional styling is applied.
      }
      bubble.textContent = text;
      messageContainer.appendChild(bubble);
      const clearDiv = document.createElement("div");
      clearDiv.classList.add("chat-clear");
      messageContainer.appendChild(clearDiv);
      messageContainer.scrollTop = messageContainer.scrollHeight;
    }

    function showTypingIndicator() {
      typingAnimation.style.display = "inline-flex";
    }

    function hideTypingIndicator() {
      typingAnimation.style.display = "none";
    }

    // Create WebSocket connection
    const socket = new WebSocket("ws://localhost:8765");

    // Connection opened
    socket.addEventListener('open', (event) => {
      console.log('Connected to WebSocket server');
      statusDot.style.backgroundColor = "#4caf50";
      statusText.textContent = "online";
      messageContainer.classList.remove("offline");
      chatHeader.classList.remove("offline");
    });
    
    // Handle WebSocket closure to indicate offline status (red indicator)
    socket.addEventListener('close', (event) => {
      console.log('WebSocket connection closed');
      statusDot.style.backgroundColor = "#f44336";
      statusText.textContent = "offline";
      messageContainer.classList.add("offline");
      chatHeader.classList.add("offline");
    });
    
    // Handle WebSocket errors to indicate offline status (red indicator)
    socket.addEventListener('error', (event) => {
      console.log('WebSocket error');
      statusDot.style.backgroundColor = "#f44336";
      statusText.textContent = "offline";
      messageContainer.classList.add("offline");
      chatHeader.classList.add("offline");
    });

    // Listen for messages from the server
    socket.addEventListener('message', (event) => {
      try {
        // Try to parse as JSON first
        const data = JSON.parse(event.data);
        
        if (data.type === "status_message") {
          // Update the right-side status text bar using the new function
          updateRuntimeStatus(data.message);
          
          // Detect status type from the message content for proper styling
          if (data.message.includes("Starting") || 
             data.message.includes("Processing") || 
             data.message.includes("Analyzing") ||
             data.message.includes("Executing")) {
            updateRuntimeStatus(data.message, "processing");
          } else if (data.message.includes("✅") || 
                    data.message.includes("success")) {
            updateRuntimeStatus(data.message, "success");
          } else if (data.message.includes("❌") || 
                    data.message.includes("Error") || 
                    data.message.includes("failed")) {
            updateRuntimeStatus(data.message, "error");
          }
          
          // Check for attempt number updates in status messages - support both formats
          const attemptMatch = data.message.match(/Starting (?:block creation and execution )?attempt (\d+) of (\d+)/);
          if (attemptMatch) {
            const current = attemptMatch[1];
            const max = attemptMatch[2];
            // Update the attempt number display in protoblock header
            document.getElementById('protoblockAttempt').textContent = `Attempt ${current}/${max}`;
            console.log(`Updated attempt number to ${current}/${max}`);
            
            // Don't hide the protoblock here - it will be replaced when the new one is created
          }
          
          // Check for block execution failure message
          if (data.message === "❌ Block execution failed!" || 
              data.message.startsWith("❌ Error:") ||
              data.message.includes("Error creating protoblock:") ||
              data.message.includes("Execution attempt") && data.message.includes("failed")) {
            console.log("Removing protoblock display due to failure message");
            // Force the canvas to be shown and protoblock to be hidden
            document.getElementById('protoblockContainer').style.display = 'none';
            document.querySelector('#blockPanel canvas').style.display = 'block';
            // Don't clear the data - just hide it
          }
          
          // Show git operations panel after successful block execution
          if (data.message === "✅ Block executed successfully! Displaying final results...") {
            console.log("Block successful, showing git operations panel");
            showGitOperationsPanel(true);
          }
          
          return;
        } 
        else if (data.type === "error_message") {
          // Display prominent error message at the top of the right panel
          const errorMessage = document.getElementById("errorMessage");
          errorMessage.textContent = data.message;
          errorMessage.style.display = "block";
          
          // Apply a slight shake animation by removing and re-adding the class
          errorMessage.classList.remove("animated");
          void errorMessage.offsetWidth; // Force reflow to restart animation
          errorMessage.classList.add("animated");
          
          // Hide the error message after 30 seconds to allow plenty of time to read
          setTimeout(() => {
            errorMessage.style.display = "none";
          }, 30000);
          
          return;
        }
        else if (data.type === "info_message") {
          // Display info message at the bottom of the right panel
          const infoMessage = document.getElementById("infoMessage");
          infoMessage.textContent = data.message;
          infoMessage.style.display = "block";
          
          // Automatically hide after 15 seconds
          setTimeout(() => {
            infoMessage.style.display = "none";
          }, 15000);
          
          return;
        }
        else if (data.type === "remove_protoblock") {
          // This is an explicit message to remove the protoblock display
          console.log("Received explicit remove_protoblock message");
          
          // Force the canvas to be shown and protoblock to be hidden
          document.getElementById('protoblockContainer').style.display = 'none';
          document.querySelector('#blockPanel canvas').style.display = 'block';
          
          // Clear any existing protoblock data and rebuild the container
          document.getElementById('protoblockContainer').innerHTML = '';
          rebuildProtoblockContainer();
          
          // Update runtime status 
          document.getElementById("runtimeStatus").textContent = data.message || "Block processing complete";
          return;
        }
        else if (data.type === "protoblock_data") {
          // Display protoblock data in the right panel
          console.log("Received protoblock data:", data);
          
          // Ensure the protoblock container is visible
          document.getElementById('protoblockContainer').style.display = 'block';
          document.querySelector('#blockPanel canvas').style.display = 'none';
          
          // Display the data
          displayProtoblockData(data);
          
          console.log("Protoblock is now visible");
          return;
        }
        else if (data.type === "transcribed_message") {
          // Display as a user message
          addChatMessage("User", data.message);
          
          // Send it back to server for processing
          const payload = {
            type: "user_message",
            message: data.message
          };
          socket.send(JSON.stringify(payload));
          showTypingIndicator();

          // Remove any indication (waiting, recording, transcribing) from micButton once transcription is received
          micButton.classList.remove('waiting');
          micButton.classList.remove('recording');
          micButton.classList.remove('rotating');
          micButton.classList.remove('transcribing');
          return;
        }
        else if (data.type === "file_status_response" || 
                data.type === "file_diff_response" || 
                data.type === "git_branch_response" || 
                data.type === "git_operation_response") {
          // Ignore these types of messages - don't display in chat
          console.log(`Received ${data.type}`);
          return;
        }
        else {
          // Regular AI response
          addChatMessage("AI", event.data);
          // Immediately hide typing indicator after full display of AI message
          hideTypingIndicator();
        }
      } catch (e) {
        // If not JSON or parsing fails, treat as a regular message
        addChatMessage("AI", event.data);
        hideTypingIndicator();
      }
    });

    // Send user message when Enter key is pressed (without Shift)
    userInput.addEventListener("keydown", function(event) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        const text = userInput.value.trim();
        if (text !== "") {
          // Display user's message in the chat history
          addChatMessage("User", text);
          
          // Format the message as JSON
          const payload = {
            type: "user_message",
            message: text
          };
          
          // Send the message to the server via WebSocket and show typing animation
          socket.send(JSON.stringify(payload));
          showTypingIndicator();
          userInput.value = "";
        }
      }
    });

    // Bind click event to the block button for cube-like interaction
    const blockButton = document.getElementById('blockButton');
    blockButton.addEventListener('click', function() {
      // Immediately update the runtime status to reflect the protoblock execution process
      updateRuntimeStatus("Executing protoblock...", "processing");
      
      // Hide the protoblock display when starting a new block generation
      toggleProtoblockDisplay(false);
      
      // Clear any existing protoblock data
      document.getElementById('protoblockContainer').innerHTML = '';
      rebuildProtoblockContainer();
      
      // Add active class to trigger animation
      blockButton.classList.add('active');
      // Remove active class after a short delay to revert to original state
      setTimeout(() => {
        blockButton.classList.remove('active');
      }, 300);
      
      // If there is a message typed in, send it first to the chat system
      const text = userInput.value.trim();
      if (text !== "") {
        addChatMessage("User", text);
        const messagePayload = {
          type: "user_message",
          message: text
        };
        socket.send(JSON.stringify(messagePayload));
        showTypingIndicator();
        userInput.value = "";
      }
      
      // Initiate block processing by sending the block_click payload
      const payload = {
        type: "block_click"
      };
      socket.send(JSON.stringify(payload));
    });

    // Bind click event to the microphone button to send the 'mic_click' event to the backend
    let isRecording = false; // flag to track recording state

    micButton.addEventListener('click', function() {
      // Toggle the recording state
      isRecording = !isRecording;
      if (isRecording) {
        // Start recording: add 'recording' class to display red indicator and remove rotating if set
        micButton.classList.add('recording');
        micButton.classList.remove('rotating');
        micButton.classList.remove('transcribing');
      } else {
        // Stop recording: remove 'recording' class and add 'transcribing' class to indicate ongoing transcription
        micButton.classList.remove('recording');
        micButton.classList.remove('rotating');
        micButton.classList.add('transcribing');
      }
      const payload = {
        type: "mic_click",
        recording: isRecording
      };
      socket.send(JSON.stringify(payload));
    });

    // Initialize Three.js scene for the rotating cube inside the block button
    const btnCanvas = document.getElementById('cubeCanvas');
    const btnRenderer = new THREE.WebGLRenderer({ canvas: btnCanvas, antialias: true, alpha: true });
    btnRenderer.setPixelRatio(window.devicePixelRatio);
    btnRenderer.setClearColor(0x000000, 0);
    btnRenderer.setSize(32, 32);

    const btnScene = new THREE.Scene();
    const btnCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    btnCamera.position.z = 2;

    // Updated cube geometry dimensions for a visibly larger cube
    const btnGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
    const btnMaterial = new THREE.MeshPhongMaterial({ 
      color: 0x0078d7, 
      shininess: 100, 
      wireframe: true, 
      transparent: true, 
      opacity: 0.7,
      emissive: 0x0078d7, 
      emissiveIntensity: 0.5
    });
    const btnCube = new THREE.Mesh(btnGeometry, btnMaterial);
    btnScene.add(btnCube);

    const btnAmbient = new THREE.AmbientLight(0xffffff, 0.8);
    btnScene.add(btnAmbient);

    function animateBtnCube() {
      requestAnimationFrame(animateBtnCube);
      btnCube.rotation.x += 0.02;
      btnCube.rotation.y += 0.02;
      btnRenderer.render(btnScene, btnCamera);
    }
    animateBtnCube();

    // Initially hide the protoblock display
    toggleProtoblockDisplay(false);

    // Initialize the protoblock container structure
    rebuildProtoblockContainer();

    // Expose socket and cube for testing purposes
    window.socket = socket;
    window.cube = cube;
    
    // Git Operations Functionality
    let hasPendingChanges = false;
    let availableBranches = [];
    
    // Function to show git operations panel after successful block execution
    function showGitOperationsPanel(show) {
      const gitPanel = document.getElementById('gitOperationsPanel');
      const inputContainer = document.getElementById('inputContainer');
      
      if (!gitPanel) return;
      
      if (show) {
        // Show git panel and hide input
        gitPanel.style.display = 'block';
        inputContainer.style.display = 'none';
        
        // Request available branches
        requestBranchList();
        
        console.log("Git operations panel shown, chat input hidden");
      } else {
        // Hide git panel and show input
        gitPanel.style.display = 'none';
        inputContainer.style.display = 'flex';
        
        console.log("Git operations panel hidden, chat input shown");
      }
    }
    
    // Function to request list of available branches
    function requestBranchList() {
      if (socket && socket.readyState === WebSocket.OPEN) {
        const request = {
          type: "git_branch_request"
        };
        socket.send(JSON.stringify(request));
      }
    }
    
    // Function to handle commit changes button click
    function handleCommitChanges() {
      if (socket && socket.readyState === WebSocket.OPEN) {
        // Get the task description to use as commit message
        const taskDescription = document.getElementById('taskDescription').textContent.trim();
        const commitMsg = taskDescription.length > 50 
          ? taskDescription.substring(0, 47) + '...' 
          : taskDescription;
          
        // Show operation in progress
        document.getElementById("runtimeStatus").textContent = "Committing changes...";
        updateRuntimeStatus("Committing changes...", "processing");
        
        const request = {
          type: "git_commit_request",
          commit_message: commitMsg
        };
        socket.send(JSON.stringify(request));
      }
    }
    
    // Function to handle discard changes button click
    function handleDiscardChanges() {
      if (confirm("Are you sure you want to discard all changes?")) {
        if (socket && socket.readyState === WebSocket.OPEN) {
          // Show operation in progress
          document.getElementById("runtimeStatus").textContent = "Discarding changes...";
          updateRuntimeStatus("Discarding changes...", "processing");
          
          const request = {
            type: "git_discard_request"
          };
          socket.send(JSON.stringify(request));
        }
      }
    }
    
    // Function to handle merge with branch button click
    function handleMergeBranch() {
      const branchSelect = document.getElementById('branchSelect');
      const selectedBranch = branchSelect.value;
      
      if (!selectedBranch) {
        alert("Please select a branch to merge with");
        return;
      }
      
      if (confirm(`Are you sure you want to merge changes into ${selectedBranch} and delete the current branch?`)) {
        if (socket && socket.readyState === WebSocket.OPEN) {
          // Show operation in progress
          document.getElementById("runtimeStatus").textContent = `Merging to ${selectedBranch}...`;
          updateRuntimeStatus(`Merging to ${selectedBranch}...`, "processing");
          
          const request = {
            type: "git_merge_request",
            target_branch: selectedBranch
          };
          socket.send(JSON.stringify(request));
        }
      }
    }
    
    // Wait for DOMContentLoaded to ensure all elements are available
    document.addEventListener('DOMContentLoaded', function() {
      // Set up git operation button event listeners
      const commitBtn = document.getElementById('commitChangesBtn');
      const discardBtn = document.getElementById('discardChangesBtn');
      const mergeBtn = document.getElementById('mergeBtn');
      
      if (commitBtn) {
        commitBtn.addEventListener('click', handleCommitChanges);
      }
      
      if (discardBtn) {
        discardBtn.addEventListener('click', handleDiscardChanges);
      }
      
      if (mergeBtn) {
        mergeBtn.addEventListener('click', handleMergeBranch);
      }
      
      // Listen for git-related responses
      socket.addEventListener('message', function(event) {
        try {
          const data = JSON.parse(event.data);
          
          // Handle git branch response
          if (data.type === "git_branch_response") {
            // Populate branch dropdown
            const branchSelect = document.getElementById('branchSelect');
            availableBranches = data.branches || [];
            
            // Clear existing options
            while (branchSelect.options.length > 1) {
              branchSelect.remove(1);
            }
            
            // Add new options
            availableBranches.forEach(branch => {
              const option = document.createElement('option');
              option.value = branch;
              option.textContent = branch;
              branchSelect.appendChild(option);
            });
          }
          
          // Handle git operation response
          else if (data.type === "git_operation_response") {
            if (data.success) {
              // Display success message
              document.getElementById("runtimeStatus").textContent = `✅ ${data.message}`;
              updateRuntimeStatus(`✅ ${data.message}`, "success");
              
              // Update UI based on operation
              if (data.operation === "commit") {
                // Hide git panel after commit
                document.getElementById('gitOperationsPanel').style.display = 'none';
                
                // Wait a bit and disable entirely
                setTimeout(() => {
                  showGitOperationsPanel(false);
                }, 100);
              }
              else if (data.operation === "discard") {
                // Hide git panel and refresh the page to show original state
                document.getElementById('gitOperationsPanel').style.display = 'none';
                setTimeout(() => {
                  window.location.reload();
                }, 1000);
              }
              else if (data.operation === "merge") {
                // Hide git panel and refresh the page
                document.getElementById('gitOperationsPanel').style.display = 'none';
                setTimeout(() => {
                  window.location.reload();
                }, 1000);
              }
            } else {
              // Display error message
              document.getElementById("runtimeStatus").textContent = `❌ ${data.message}`;
              updateRuntimeStatus(`❌ ${data.message}`, "error");
            }
          }
        } catch (e) {
          // Not JSON
        }
      });
    });

    // Function to make file list items clickable
    function makeFilesClickable() {
      const writeFilesList = document.getElementById('writeFilesList');
      
      console.log("Making files clickable");
      
      // Only apply click handlers if block execution was successful
      const runtimeStatus = document.getElementById('runtimeStatus');
      const blockStatusTextContent = document.getElementById('blockStatusText')?.textContent || "";
      const isSuccess = blockStatusTextContent.includes("✅") || 
                       blockStatusTextContent.includes("successful") ||
                       blockStatusTextContent.includes("Ready");
      
      if (isSuccess) {
        // Make write files clickable
        const writeFileItems = writeFilesList.querySelectorAll('li');
        console.log(`Found ${writeFileItems.length} write files to make clickable`);
        
        writeFileItems.forEach(item => {
          // Remove existing event listeners by cloning the node
          const newItem = item.cloneNode(true);
          item.parentNode.replaceChild(newItem, item);
          
          // Extract just the filename without any badges or added elements
          const filename = newItem.childNodes[0].textContent.trim();
          
          newItem.classList.add('clickable-file');
          newItem.addEventListener('click', (event) => {
            // Prevent clicks on badges from triggering the diff view
            if (event.target.closest('.line-count-badge')) {
              return;
            }
            
            console.log(`Clicked on file: ${filename}`);
            showFileDiff(filename);
          });
          
          // Request file status to highlight modified files
          checkFileStatus(filename);
        });
      } else {
        console.log("Block execution not successful, not making files clickable");
      }
    }

    // Function to check if a file has been modified
    function checkFileStatus(filename) {
      if (socket && socket.readyState === WebSocket.OPEN) {
        const request = {
          type: "file_status_request",
          filename: filename
        };
        socket.send(JSON.stringify(request));
      }
    }

    // Function to send message to server to request file diff
    function requestFileDiff(filename) {
      if (socket && socket.readyState === WebSocket.OPEN) {
        const request = {
          type: "file_diff_request",
          filename: filename
        };
        socket.send(JSON.stringify(request));
      }
    }

    // Update the displayProtoblockData function to make files clickable
    const originalDisplayProtoblockData = displayProtoblockData;
    displayProtoblockData = function(data) {
      // Call the original function
      originalDisplayProtoblockData(data);
      
      // Check if this is a successful block execution
      const runtimeStatus = document.getElementById('runtimeStatus');
      const blockStatusTextContent = document.getElementById('blockStatusText')?.textContent || "";
      const isSuccess = blockStatusTextContent.includes("✅") || 
                       blockStatusTextContent.includes("successful") ||
                       blockStatusTextContent.includes("Ready");
                       
      if (isSuccess) {
        // Make files clickable after a delay to ensure the DOM is ready
        setTimeout(makeFilesClickable, 300);
      }
    };

    // Add handling for file_status_response messages
    socket.addEventListener('message', (event) => {
      try {
        const data = JSON.parse(event.data);
        
        if (data.type === "file_status_response") {
          // Handle file status update
          const { filename, is_modified, error, added_lines, removed_lines } = data;
          
          if (error) {
            console.log(`Error checking status for ${filename}: ${error}`);
            return;
          }
          
          // Find the file item in the write files list
          const writeFilesList = document.getElementById('writeFilesList');
          if (!writeFilesList) return;
          
          const items = writeFilesList.querySelectorAll('li');
          items.forEach(item => {
            // Extract the actual filename from the first text node
            let itemFilename = '';
            if (item.childNodes.length > 0 && item.childNodes[0].nodeType === Node.TEXT_NODE) {
              itemFilename = item.childNodes[0].textContent.trim();
            } else {
              itemFilename = item.textContent.trim();
            }
            
            if (itemFilename === filename.trim()) {
              // Update class based on modification status
              if (is_modified) {
                item.classList.add('modified-file');
                
                // Add line counts if available
                if (added_lines > 0 || removed_lines > 0) {
                  // Create line count display
                  let lineCountHTML = '';
                  
                  if (added_lines > 0) {
                    lineCountHTML += `<span class="line-count-added">+${added_lines}</span>`;
                  }
                  
                  if (removed_lines > 0) {
                    lineCountHTML += `<span class="line-count-removed">-${removed_lines}</span>`;
                  }
                  
                  // Add the line count badge
                  const badge = document.createElement('span');
                  badge.className = 'line-count-badge';
                  badge.innerHTML = lineCountHTML;
                  
                  // Remove any existing badge first
                  const existingBadge = item.querySelector('.line-count-badge');
                  if (existingBadge) {
                    item.removeChild(existingBadge);
                  }
                  
                  // Add new badge
                  item.appendChild(badge);
                }
              } else {
                item.classList.remove('modified-file');
                // Remove any existing line count badge
                const existingBadge = item.querySelector('.line-count-badge');
                if (existingBadge) {
                  item.removeChild(existingBadge);
                }
              }
            }
          });
        }
      } catch (e) {
        // Not JSON or not a file_status_response
      }
    });

    // When we get a file_diff_response, handle both unified and split views
    socket.addEventListener('message', (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === "file_diff_response") {
          // Display the diff in the overlay
          fileDiffTitle.textContent = `Changes in ${data.filename}`;
          
          // Format and display the diff with syntax highlighting
          let formattedDiff = '';
          
          if (data.error) {
            formattedDiff = `<div class="diff-error">Error: ${data.error}</div>`;
            fileDiffBody.innerHTML = formattedDiff;
            fileDiffLeft.innerHTML = formattedDiff;
            fileDiffRight.innerHTML = formattedDiff;
          } else if (!data.diff || data.diff.trim() === '') {
            formattedDiff = '<div class="diff-empty">No changes detected for this file.</div>';
            fileDiffBody.innerHTML = formattedDiff;
            fileDiffLeft.innerHTML = formattedDiff;
            fileDiffRight.innerHTML = formattedDiff;
          } else {
            // Handle the case where diff is just file content
            if (data.diff.startsWith("Full file content") || data.diff.startsWith("File is tracked")) {
              // Simple content display
              const content = data.diff.replace(/^Full file content.*?\n/g, '');
              formattedDiff = `<div class="diff-section">${data.diff.split('\n')[0]}</div>`;
              formattedDiff += `<pre class="diff-unchanged">${escapeHtml(content)}</pre>`;
              
              // For split view, show the same content on both sides
              fileDiffLeft.innerHTML = `<div class="diff-file-header">Original</div><pre>${escapeHtml(content)}</pre>`;
              fileDiffRight.innerHTML = `<div class="diff-file-header">Modified</div><pre>${escapeHtml(content)}</pre>`;
              window.currentDiffLineCount = content.split('\n').length + 5; // +5 for headers
            } else {
              // Process the diff for unified view
              const diffLines = data.diff.split('\n');
              let inSection = false;
              
              diffLines.forEach(line => {
                if (line.startsWith("=== ") && line.endsWith(" ===")) {
                  // Section header (staged/unstaged)
                  formattedDiff += `<div class="diff-section">${line}</div>`;
                  inSection = true;
                } else if (line.startsWith('+') && !line.startsWith('+++')) {
                  formattedDiff += `<div class="diff-added">${escapeHtml(line)}</div>`;
                } else if (line.startsWith('-') && !line.startsWith('---')) {
                  formattedDiff += `<div class="diff-removed">${escapeHtml(line)}</div>`;
                } else if (line.startsWith('@@')) {
                  formattedDiff += `<div class="diff-header">${escapeHtml(line)}</div>`;
                } else if (line.startsWith('diff') || line.startsWith('---') || line.startsWith('+++')) {
                  formattedDiff += `<div class="diff-header">${escapeHtml(line)}</div>`;
                } else {
                  formattedDiff += `<div class="diff-unchanged">${escapeHtml(line)}</div>`;
                }
              });
              
              // Create split view
              const splitViewContent = parseDiffForSplitView(data.diff);
              fileDiffLeft.innerHTML = splitViewContent.left;
              fileDiffRight.innerHTML = splitViewContent.right;
              window.currentDiffLineCount = splitViewContent.lineCount;
            }
            
            fileDiffBody.innerHTML = formattedDiff;
          }
          
          fileDiffOverlay.style.display = 'flex';
          
          // Set the view mode according to current setting
          if (diffViewMode === 'unified') {
            fileDiffBody.style.display = 'block';
            fileDiffSplitView.style.display = 'none';
            fileDiffViewToggle.textContent = 'Split View';
          } else {
            fileDiffBody.style.display = 'none';
            fileDiffSplitView.style.display = 'flex';
            fileDiffViewToggle.textContent = 'Unified View';
            // Setup synchronized scrolling
            setupSplitViewScrolling();
          }
        }
      } catch (e) {
        // Not JSON or not a file diff response
        console.log("Error parsing message:", e);
      }
    });

    // Trusty Agent Prompt Overlay functionality
    const trustyAgentOverlay = document.getElementById('trustyAgentOverlay');
    const trustyAgentCloseBtn = document.getElementById('trustyAgentCloseBtn');
    const trustyAgentBody = document.getElementById('trustyAgentBody');
    const trustyAgentTitle = document.getElementById('trustyAgentTitle');

    // Function to show a specific trusty agent prompt
    function showTrustyAgentPrompt(agentName, agentKey) {
      console.log(`Showing prompt for agent: ${agentName} (key: ${agentKey})`);
      
      // Set the title
      trustyAgentTitle.textContent = `${agentName}`;
      
      // Get the prompt
      const prompt = window.trustyAgentPrompts[agentName] || '';
      console.log(`Prompt for ${agentName}:`, prompt ? 'exists' : 'not found');
      
      // Get the results (if any)
      // Try both the full name and the key name to match backend storage
      const results = window.trustyAgentResults && 
                     (window.trustyAgentResults[agentName] || window.trustyAgentResults[agentKey] || null);
      
      console.log(`Results for ${agentName}:`, results || 'not found');
      
      // Set the prompt text
      const promptTextElement = document.getElementById('trustyAgentPromptText');
      promptTextElement.textContent = prompt || 'No prompt available for this agent.';
      
      // Process results if available
      const resultSection = document.getElementById('trustyAgentResultSection');
      const resultTextElement = document.getElementById('trustyAgentResultText');
      const resultStatusElement = document.getElementById('trustyAgentResultStatus');
      const imageSection = document.getElementById('trustyAgentImageSection');
      const imageElement = document.getElementById('trustyAgentImage');
      
      // Get the runtime status to check if execution was successful
      const runtimeStatus = document.getElementById('runtimeStatus');
      const executionSuccessful = runtimeStatus.textContent.includes("✅");
      
      if (results && (results.output || results.image_url)) {
        console.log(`${agentName} has results to display`);
        
        // Show result section if there's output text
        if (results.output) {
          console.log(`${agentName} output:`, results.output);
          resultSection.style.display = 'block';
          resultTextElement.textContent = results.output;
          
          // Set status indicator
          if (results.status) {
            resultStatusElement.className = 'agent-status ' + results.status;
            let statusText = '';
            switch (results.status) {
              case 'passed':
                statusText = 'Verification Passed ✅';
                break;
              case 'failed':
                statusText = 'Verification Failed ❌';
                break;
              case 'error':
                statusText = 'Execution Error ⚠️';
                break;
              default:
                statusText = results.status;
            }
            resultStatusElement.textContent = statusText;
            resultStatusElement.style.display = 'inline-block';
          } else {
            resultStatusElement.style.display = 'none';
          }
        } else {
          resultSection.style.display = 'none';
        }
        
        // Show image section if there's an image URL
        if (results.image_url) {
          console.log(`${agentName} image URL:`, results.image_url);
          imageSection.style.display = 'block';
          imageElement.src = results.image_url;
        } else {
          imageSection.style.display = 'none';
        }
      } else {
        console.log(`${agentName} has no results to display`);
        
        // Show message based on execution status
        resultSection.style.display = 'block';
        resultStatusElement.style.display = 'none';
        
        if (executionSuccessful) {
          // Execution was successful but no results for this agent
          resultTextElement.innerHTML = '<div class="diff-empty">This agent was executed but did not produce any output.</div>';
        } else {
          // Execution may still be in progress or failed
          resultTextElement.innerHTML = '<div class="diff-empty">No results available yet for this agent.</div>';
        }
        
        imageSection.style.display = 'none';
      }
      
      // Show the overlay
      trustyAgentOverlay.style.display = 'flex';
    }

    // Close overlay when clicking the close button
    trustyAgentCloseBtn.addEventListener('click', () => {
      trustyAgentOverlay.style.display = 'none';
    });

    // Close overlay when clicking outside the content
    trustyAgentOverlay.addEventListener('click', (event) => {
      if (event.target === trustyAgentOverlay) {
        trustyAgentOverlay.style.display = 'none';
      }
    });

    function displayTrustyAgentPrompt(agentName, protoblock) {
      console.log("Displaying prompt for agent:", agentName);
      const trustyAgentOverlay = document.getElementById('trustyAgentOverlay');
      const trustyAgentTitle = document.getElementById('trustyAgentTitle');
      const trustyAgentPromptText = document.getElementById('trustyAgentPromptText');
      const trustyAgentResultSection = document.getElementById('trustyAgentResultSection');
      const trustyAgentResultText = document.getElementById('trustyAgentResultText');
      const trustyAgentImageSection = document.getElementById('trustyAgentImageSection');
      const trustyAgentImage = document.getElementById('trustyAgentImage');
      const trustyAgentAgentType = document.getElementById('trustyAgentAgentType');
      const trustyAgentResultStatus = document.getElementById('trustyAgentResultStatus');
      const trustyAgentComparisonImage = document.getElementById('trustyAgentComparisonImage');
      const comparisonImageContainer = document.getElementById('comparisonImageContainer');
      const trustyAgentTestResultsSection = document.getElementById('trustyAgentTestResultsSection');
      const trustyAgentTestResults = document.getElementById('trustyAgentTestResults');
      const trustyAgentSummarySection = document.getElementById('trustyAgentSummarySection');
      const trustyAgentSummary = document.getElementById('trustyAgentSummary');
      const trustyAgentPlausibilitySection = document.getElementById('trustyAgentPlausibilitySection');
      const trustyAgentGrade = document.getElementById('trustyAgentGrade');
      const trustyAgentGradeInfo = document.getElementById('trustyAgentGradeInfo');
      const trustyAgentVerificationInfo = document.getElementById('trustyAgentVerificationInfo');

      // Display the overlay
      trustyAgentOverlay.style.display = 'flex';

      // Set the title
      trustyAgentTitle.textContent = `Trusty Agent: ${agentName}`;

      // Set the prompt text
      const agentKey = agentName.toLowerCase();
      let agentPrompt = "";

      // Check if the prompt exists for the agent
      let hasPrompt = false;
      if (protoblock.trusty_agent_prompts && protoblock.trusty_agent_prompts[agentKey]) {
        hasPrompt = true;
        agentPrompt = protoblock.trusty_agent_prompts[agentKey];
      }

      trustyAgentPromptText.textContent = hasPrompt ? agentPrompt : "No prompt found for this agent.";

      // Check if there are results for this agent
      let resultObj = null;
      let hasResults = false;
      
      if (protoblock.trusty_agent_results) {
        console.log("Available trusty agent results:", Object.keys(protoblock.trusty_agent_results));
        
        // Try both the full agent name and lowercase version to match backend storage
        const possibleKeys = [agentName, agentKey, agentName.toLowerCase(), agentKey.replace('agent', '')];
        
        for (const key of possibleKeys) {
          if (protoblock.trusty_agent_results[key]) {
            resultObj = protoblock.trusty_agent_results[key];
            hasResults = (resultObj.output !== undefined || resultObj.image_url !== undefined);
            console.log(`Found results for ${agentKey} using key '${key}':`, resultObj);
            break;
          }
        }
      }
      
      // Helper function to make file paths usable in the browser
      function makePathUsable(path) {
        if (!path) return null;
        
        // If it's already a URL or a relative path, return as is
        if (path.startsWith('http') || path.startsWith('data:') || path.startsWith('./') || path.startsWith('/')) {
          return path;
        }
        
        // Convert absolute path to a file URL
        try {
          return 'file://' + path;
        } catch (e) {
          console.error('Error processing path:', e);
          return path;
        }
      }

      // Clear previous display state
      trustyAgentResultSection.style.display = 'none';
      trustyAgentImageSection.style.display = 'none';
      trustyAgentTestResultsSection.style.display = 'none';
      trustyAgentSummarySection.style.display = 'none';
      trustyAgentPlausibilitySection.style.display = 'none';

      // Display or hide the result section based on whether there are results
      if (hasResults && resultObj) {
        // Check if this is the plausibility agent
        const isPlausibilityAgent = 
          agentKey === 'plausibility' || 
          agentName.toLowerCase().includes('plausibility') || 
          (resultObj.agent_type && resultObj.agent_type.toLowerCase().includes('plausibility'));
        
        if (isPlausibilityAgent) {
          // Handle special plausibility display
          trustyAgentPlausibilitySection.style.display = 'block';
          
          // Display grade
          if (resultObj.grade) {
            trustyAgentGrade.textContent = resultObj.grade;
            trustyAgentGrade.setAttribute('data-grade', resultObj.grade);
            trustyAgentGrade.style.display = 'flex';
          } else {
            trustyAgentGrade.style.display = 'none';
          }
          
          // Display grade info
          if (resultObj.grade_info) {
            trustyAgentGradeInfo.textContent = resultObj.grade_info;
            trustyAgentGradeInfo.style.display = 'block';
          } else {
            trustyAgentGradeInfo.style.display = 'none';
          }
          
          // Display verification info
          if (resultObj.verification_info) {
            trustyAgentVerificationInfo.textContent = resultObj.verification_info;
            trustyAgentVerificationInfo.style.display = 'block';
          } else {
            trustyAgentVerificationInfo.style.display = 'none';
          }
        }

        // Standard result section (text output)
        if (resultObj.output) {
          trustyAgentResultSection.style.display = 'block';
          
          // Set status badge
          if (resultObj.status) {
            trustyAgentResultStatus.textContent = resultObj.status;
            trustyAgentResultStatus.className = 'agent-status';
            if (resultObj.status.toLowerCase() === 'passed') {
              trustyAgentResultStatus.classList.add('passed');
            } else if (resultObj.status.toLowerCase() === 'failed') {
              trustyAgentResultStatus.classList.add('failed');
            } else {
              trustyAgentResultStatus.classList.add('error');
            }
          } else {
            trustyAgentResultStatus.textContent = '';
            trustyAgentResultStatus.className = 'agent-status';
          }
          
          // Set agent type if available
          if (resultObj.agent_type) {
            trustyAgentAgentType.textContent = resultObj.agent_type;
            trustyAgentAgentType.style.display = 'inline-block';
          } else {
            trustyAgentAgentType.style.display = 'none';
          }
          
          // Set result text content
          trustyAgentResultText.textContent = resultObj.output || "No text output available";
        }

        // Check if there's an image URL and display it
        if (resultObj.image_url) {
          trustyAgentImageSection.style.display = 'block';
          const usablePath = makePathUsable(resultObj.image_url);
          trustyAgentImage.src = usablePath;
          console.log(`Setting main image src to: ${usablePath}`);
        } else {
          trustyAgentImageSection.style.display = 'none';
        }
        
        // Check for comparison image
        if (resultObj.comparison_path) {
          comparisonImageContainer.style.display = 'block';
          const usablePath = makePathUsable(resultObj.comparison_path);
          trustyAgentComparisonImage.src = usablePath;
          console.log(`Setting comparison image src to: ${usablePath}`);
        } else {
          comparisonImageContainer.style.display = 'none';
        }
        
        // Check for screenshot path (which might be different from image_url)
        if (!resultObj.image_url && resultObj.screenshot_path) {
          trustyAgentImageSection.style.display = 'block';
          const usablePath = makePathUsable(resultObj.screenshot_path);
          trustyAgentImage.src = usablePath;
          console.log(`Setting image from screenshot_path: ${usablePath}`);
        }
        
        // Check for test results
        if (resultObj.test_results) {
          trustyAgentTestResultsSection.style.display = 'block';
          trustyAgentTestResults.textContent = resultObj.test_results;
        } else {
          trustyAgentTestResultsSection.style.display = 'none';
        }
        
        // Check for summary
        if (resultObj.summary) {
          trustyAgentSummarySection.style.display = 'block';
          trustyAgentSummary.textContent = resultObj.summary;
        } else {
          trustyAgentSummarySection.style.display = 'none';
        }
      } else {
        // No results found, show a message
        trustyAgentResultSection.style.display = 'block';
        trustyAgentResultStatus.style.display = 'none';
        trustyAgentAgentType.style.display = 'none';
        trustyAgentResultText.textContent = "No results found for this agent.";
        console.log(`No results found for agent: ${agentKey}`);
      }

      // Set up the close button event listener
      const trustyAgentCloseBtn = document.getElementById('trustyAgentCloseBtn');
      trustyAgentCloseBtn.onclick = function() {
        trustyAgentOverlay.style.display = 'none';
      };
    }
  </script>
  
  <!-- File diff overlay -->
  <div id="fileDiffOverlay">
    <div id="fileDiffContent">
      <div id="fileDiffHeader">
        <h3 id="fileDiffTitle">File Changes</h3>
        <div>
          <button id="fileDiffViewToggle" title="Toggle between unified and split view">Split View</button>
          <button id="fileDiffCloseBtn">×</button>
        </div>
      </div>
      <div id="fileDiffBody"></div>
      <div id="fileDiffSplitView" class="initially-hidden">
        <div id="fileDiffLeft"></div>
        <div id="fileDiffRight"></div>
        <div id="fileDiffScrollContainer">
          <div id="fileDiffScrollContent"></div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Trusty Agent Prompt overlay -->
  <div id="trustyAgentOverlay">
    <div id="trustyAgentContent">
      <div id="trustyAgentHeader">
        <h3 id="trustyAgentTitle">Trusty Agent</h3>
        <button id="trustyAgentCloseBtn">×</button>
      </div>
      <div id="trustyAgentBody">
        <div class="trusty-agent-section">
          <div class="trusty-agent-section-title">Prompt</div>
          <div id="trustyAgentPromptText" class="code-block"></div>
        </div>
        <div class="trusty-agent-section initially-hidden" id="trustyAgentResultSection">
          <div class="trusty-agent-section-title">Result</div>
          <div id="trustyAgentResultStatus" class="agent-status"></div>
          <div id="trustyAgentAgentType" class="agent-type"></div>
          <div id="trustyAgentResultText" class="code-block"></div>
        </div>
        <div class="trusty-agent-section initially-hidden" id="trustyAgentPlausibilitySection">
          <div class="trusty-agent-section-title">Plausibility Evaluation</div>
          <div class="plausibility-container">
            <div class="plausibility-grade-container">
              <div id="trustyAgentGrade" class="grade"></div>
              <div id="trustyAgentGradeInfo" class="grade-info"></div>
            </div>
            <div id="trustyAgentVerificationInfo" class="verification-info"></div>
          </div>
        </div>
        <div class="trusty-agent-section initially-hidden" id="trustyAgentImageSection">
          <div class="trusty-agent-section-title">Screenshots</div>
          <div id="trustyAgentImageContainer">
            <div id="mainImageContainer">
              <h4>Main Screenshot</h4>
              <img id="trustyAgentImage" alt="Trusty Agent Output Image" class="constrained-image">
            </div>
            <div id="comparisonImageContainer" class="initially-hidden">
              <h4>Comparison Screenshot</h4>
              <img id="trustyAgentComparisonImage" alt="Comparison Screenshot" class="constrained-image">
            </div>
          </div>
        </div>
        <div class="trusty-agent-section initially-hidden" id="trustyAgentTestResultsSection">
          <div class="trusty-agent-section-title">Test Results</div>
          <div id="trustyAgentTestResults" class="code-block"></div>
        </div>
        <div class="trusty-agent-section initially-hidden" id="trustyAgentSummarySection">
          <div class="trusty-agent-section-title">Summary</div>
          <div id="trustyAgentSummary" class="summary-block"></div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // File diff handling
    const fileDiffOverlay = document.getElementById('fileDiffOverlay');
    const fileDiffCloseBtn = document.getElementById('fileDiffCloseBtn');
    const fileDiffBody = document.getElementById('fileDiffBody');
    const fileDiffTitle = document.getElementById('fileDiffTitle');
    const fileDiffSplitView = document.getElementById('fileDiffSplitView');
    const fileDiffLeft = document.getElementById('fileDiffLeft');
    const fileDiffRight = document.getElementById('fileDiffRight');
    const fileDiffViewToggle = document.getElementById('fileDiffViewToggle');

    let diffViewMode = 'unified'; // 'unified' or 'split'

    // Toggle between unified and split view
    fileDiffViewToggle.addEventListener('click', () => {
      if (diffViewMode === 'unified') {
        diffViewMode = 'split';
        fileDiffBody.style.display = 'none';
        fileDiffSplitView.style.display = 'flex';
        fileDiffViewToggle.textContent = 'Unified View';
        
        // Set proper height for scroll container after switching to split view
        setupSplitViewScrolling();
      } else {
        diffViewMode = 'unified';
        fileDiffBody.style.display = 'block';
        fileDiffSplitView.style.display = 'none';
        fileDiffViewToggle.textContent = 'Split View';
      }
    });
    
    // Function to set up synchronized scrolling
    function setupSplitViewScrolling() {
      const scrollContainer = document.getElementById('fileDiffScrollContainer');
      const scrollContent = document.getElementById('fileDiffScrollContent');
      const leftPane = document.getElementById('fileDiffLeft');
      const rightPane = document.getElementById('fileDiffRight');
      
      // Set height of scroll content based on line count
      if (window.currentDiffLineCount) {
        // Approximate line height of 22px
        scrollContent.style.height = (window.currentDiffLineCount * 22) + 'px';
      }
      
      // Synchronize panes with scroll container
      scrollContainer.onscroll = function() {
        leftPane.scrollTop = scrollContainer.scrollTop;
        rightPane.scrollTop = scrollContainer.scrollTop;
      };
    }

    // Function to parse a git diff and create the split view content
    function parseDiffForSplitView(diff) {
      const leftContent = [];
      const rightContent = [];
      
      // Regular expressions for parsing diff parts
      const fileHeaderRegex = /^diff --git a\/(.*) b\/(.*)$/;
      const hunkHeaderRegex = /^@@ -(\d+),(\d+) \+(\d+),(\d+) @@(.*)$/;
      
      let leftLineNumber = 1;
      let rightLineNumber = 1;
      let currentFile = '';
      let inHunk = false;
      let diffLineCount = 0;
      
      // Split the diff into lines
      const lines = diff.split('\n');
      
      // Add file header
      leftContent.push('<div class="diff-file-header">Original</div>');
      rightContent.push('<div class="diff-file-header">Modified</div>');
      diffLineCount++;
      
      // Process each line of the diff
      lines.forEach(line => {
        // Check for file header
        const fileHeaderMatch = line.match(fileHeaderRegex);
        if (fileHeaderMatch) {
          currentFile = fileHeaderMatch[1];
          leftContent.push(`<div class="diff-section-header">${currentFile}</div>`);
          rightContent.push(`<div class="diff-section-header">${currentFile}</div>`);
          diffLineCount++;
          return;
        }
        
        // Check for hunk header
        const hunkHeaderMatch = line.match(hunkHeaderRegex);
        if (hunkHeaderMatch) {
          const leftStart = parseInt(hunkHeaderMatch[1]);
          const rightStart = parseInt(hunkHeaderMatch[3]);
          
          inHunk = true;
          leftLineNumber = leftStart;
          rightLineNumber = rightStart;
          
          leftContent.push(`<div class="diff-section-header">${line}</div>`);
          rightContent.push(`<div class="diff-section-header">${line}</div>`);
          diffLineCount++;
          return;
        }
        
        // Skip other headers or non-content lines
        if (line.startsWith('---') || line.startsWith('+++') || line.startsWith('index ')) {
          return;
        }
        
        // Process content lines
        if (inHunk) {
          if (line.startsWith('-')) {
            // Line removed - show in left only
            leftContent.push(`
              <div class="diff-line diff-removed-line">
                <span class="diff-line-number">${leftLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            rightContent.push(`<div class="diff-line diff-filler"></div>`);
            leftLineNumber++;
            diffLineCount++;
          } else if (line.startsWith('+')) {
            // Line added - show in right only
            leftContent.push(`<div class="diff-line diff-filler"></div>`);
            rightContent.push(`
              <div class="diff-line diff-added-line">
                <span class="diff-line-number">${rightLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            rightLineNumber++;
            diffLineCount++;
          } else if (line.startsWith(' ')) {
            // Common line - show in both
            leftContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${leftLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            rightContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${rightLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            leftLineNumber++;
            rightLineNumber++;
            diffLineCount++;
          } else if (line.trim() === '') {
            // Empty line - show in both
            leftContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${leftLineNumber}</span>
                <span class="diff-line-content"></span>
              </div>
            `);
            rightContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${rightLineNumber}</span>
                <span class="diff-line-content"></span>
              </div>
            `);
            leftLineNumber++;
            rightLineNumber++;
            diffLineCount++;
          }
        }
      });
      
      return {
        left: leftContent.join(''),
        right: rightContent.join(''),
        lineCount: diffLineCount
      };
    }

    // Helper function to escape HTML special characters
    function escapeHtml(unsafe) {
      return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
    }

    // Close overlay when clicking the close button
    fileDiffCloseBtn.addEventListener('click', () => {
      fileDiffOverlay.style.display = 'none';
    });

    // Close overlay when clicking outside the content
    fileDiffOverlay.addEventListener('click', (event) => {
      if (event.target === fileDiffOverlay) {
        fileDiffOverlay.style.display = 'none';
      }
    });

    // Function to fetch and show file diff
    async function showFileDiff(filename) {
      fileDiffTitle.textContent = `Changes in ${filename}`;
      fileDiffBody.innerHTML = 'Loading diff...';
      fileDiffLeft.innerHTML = 'Loading...';
      fileDiffRight.innerHTML = 'Loading...';
      fileDiffOverlay.style.display = 'flex';
      
      // Send WebSocket request for file diff
      requestFileDiff(filename);
    }
  </script>
</body>
</html>