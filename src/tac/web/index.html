<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>tac.vibe</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #e0eafc, #cfdef3);
    }
    /* Container split into two equal halves */
    #splitContainer {
      display: flex;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    /* Left panel for chat interface with a clean, modern aesthetic */
    #leftPanel {
      flex: 1;
      position: relative;
      border-right: 1px solid #d0d0d0;
      background: #ffffff;
      display: flex;
      flex-direction: column;
      box-shadow: 4px 0 12px rgba(0, 0, 0, 0.05);
    }
    /* Header for chat with refined padding and subtle shadow effect */
    #chatHeader {
      display: flex;
      align-items: center;
      padding: 16px 24px;
      background-color: #ffffff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
      z-index: 10;
    }
    #chatHeader #recipientName {
      font-weight: 500;
      font-size: 18px;
      color: #333;
    }
    /* Typing animation indicator styles moved inside header and enlarged */
    #typingAnimation {
      display: none;
      margin-left: 10px;
      font-style: italic;
      color: #888;
      align-items: center;
    }
    /* Base style for animated dots; animation speed increased to 0.5s */
    #typingAnimation .dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      margin: 0 3px;
      border-radius: 50%;
      animation: typing 0.5s ease-in-out infinite;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    /* Unique dot colors and adjusted delays */
    #typingAnimation .dot:nth-child(1) {
      animation-delay: 0s;
      background: radial-gradient(circle, red, darkred);
    }
    #typingAnimation .dot:nth-child(2) {
      animation-delay: 0.1s;
      background: radial-gradient(circle, green, darkgreen);
    }
    #typingAnimation .dot:nth-child(3) {
      animation-delay: 0.2s;
      background: radial-gradient(circle, blue, darkblue);
    }
    /* Keyframes for smooth, sinusoidal vertical movement */
    @keyframes typing {
      0%   { transform: translateY(0); }
      50%  { transform: translateY(-5px); }
      100% { transform: translateY(0); }
    }
    #chatHeader #recipientStatus {
      margin-left: auto;
      display: flex;
      align-items: center;
      font-size: 14px;
      color: #4caf50;
    }
    /* New CSS rule to update the offline status text color to red */
    #chatHeader.offline #recipientStatus {
      color: #f44336;
    }
    .statusDot {
      width: 8px;
      height: 8px;
      background-color: #4caf50;
      border-radius: 50%;
      display: inline-block;
      margin-right: 6px;
    }
    /* Chat message container within left panel */
    #messageContainer {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      color: #555;
      background-color: #fafafa;
    }
    /* When offline, change chat bubble text to red */
    #messageContainer.offline .chat-bubble {
      color: red;
    }
    /* Input container now uses flex layout to allocate dedicated space to the text field and buttons */
    #inputContainer {
      margin: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    /* Chat input area with modern styling; allow dynamic resizing within available space */
    #userInput {
      flex: 1;
      min-width: 300px;
      min-height: 40px;
      height: 60px;
      font-size: 16px;
      padding: 12px;
      background-color: #ffffff;
      color: #333;
      border: 1px solid #c3c3c3;
      border-radius: 12px;
      resize: none;
      outline: none;
      transition: border-color 0.3s, box-shadow 0.3s;
      box-sizing: border-box;
    }
    #userInput:focus {
      border-color: #007bff;
      box-shadow: 0 0 10px rgba(0, 123, 255, 0.3);
    }
    /* Container for the action buttons on the right side of the input field */
    #buttonContainer {
      display: flex;
      gap: 10px;
    }
    /* Common styling for both action buttons with a rounded rectangle border */
    .action-button {
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #c3c3c3;
      background-color: #ffffff;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.3s;
      border-radius: 12px;
    }
    /* CSS rule to display a red indicator when recording */
    .action-button.recording {
      background-color: red;
    }
    /* Subtle hover effect for action buttons with a gentle brightness increase */
    .action-button:hover {
      filter: brightness(1.1);
    }
    /* Additional smoother animation for block button when active */
    #blockButton.active {
      transform: scale(1.1);
      transition: transform 0.3s ease-in-out;
    }
    /* Keyframes for pulsating effect */
    @keyframes pulsate {
      0% {
        transform: scale(1);
        filter: brightness(1);
      }
      50% {
        transform: scale(1.1);
        filter: brightness(1.5);
      }
      100% {
        transform: scale(1);
        filter: brightness(1);
      }
    }
    /* Animation keyframes for rotating effect */
    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    /* CSS rule for rotating mic button to indicate ongoing transcription */
    #micButton.rotating {
      animation: rotate 1s linear infinite;
    }
    
    /* New animation for mic button during transcription */
    @keyframes wave {
      0% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(0, 123, 255, 0); }
      100% { box-shadow: 0 0 0 0 rgba(0, 123, 255, 0); }
    }
    
    #micButton.transcribing {
      background-color: #e8f4ff;
      animation: wave 1.5s ease-out infinite;
      border-color: #007bff;
      color: #007bff;
    }
    /* Right panel for Three.js canvas with a modern dark gradient */
    #rightPanel {
      flex: 1;
      position: relative;
      background: linear-gradient(135deg, #e0eafc, #cfdef3);
      box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.1);
      overflow-y: auto;
    }
    /* Ensure Three.js canvas fills its container */
    #rightPanel canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }
    /* Styling for the new runtime status text field in the right panel */
    #runtimeStatus {
      position: absolute;
      top: 16px;
      left: 0;
      right: 0;
      width: 75%;
      margin: 0 auto;
      color: #333;
      font-size: 18px;
      background-color: rgba(255, 255, 255, 0.7);
      padding: 8px 12px;
      border-radius: 4px;
      text-align: center;
      z-index: 10;
    }
    /* Info message styling */
    #infoMessage {
      position: absolute;
      bottom: 16px;
      left: 0;
      right: 0;
      width: 75%;
      margin: 0 auto;
      color: #0366d6;
      font-size: 16px;
      background-color: rgba(230, 247, 255, 0.9);
      padding: 12px;
      border-radius: 4px;
      text-align: center;
      z-index: 10;
      border-left: 4px solid #0366d6;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      display: none; /* Hidden by default */
      animation: fadeIn 0.5s;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    /* Error message styling - prominent red alert */
    #errorMessage {
      position: absolute;
      top: 60px;
      left: 0;
      right: 0;
      width: 75%;
      margin: 0 auto;
      color: #721c24;
      font-size: 16px;
      background-color: rgba(248, 215, 218, 0.95);
      padding: 15px;
      border-radius: 4px;
      text-align: center;
      z-index: 20; /* Higher than info message */
      border-left: 4px solid #dc3545;
      box-shadow: 0 4px 12px rgba(220, 53, 69, 0.2);
      display: none; /* Hidden by default */
      animation: fadeInShake 0.7s;
    }
    @keyframes fadeInShake {
      0% { opacity: 0; transform: translateY(-10px); }
      60% { opacity: 1; transform: translateY(0); }
      70% { transform: translateX(-5px); }
      80% { transform: translateX(5px); }
      90% { transform: translateX(-2px); }
      100% { transform: translateX(0); }
    }
    /* Protoblock display container styling */
    #protoblockContainer {
      display: none;
      width: 90%;
      margin: 70px auto 20px;
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      color: #333;
      font-size: 14px;
    }
    #protoblockHeader {
      text-align: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid #eee;
    }
    #protoblockHeader h2 {
      margin: 0 0 5px;
      color: #333;
      font-size: 22px;
    }
    #protoblockHeader p {
      margin: 0;
      color: #666;
    }
    .section {
      margin-bottom: 20px;
    }
    .section-title {
      font-weight: 500;
      color: #007bff;
      font-size: 16px;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #eee;
    }
    .file-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .file-list li {
      background-color: #f5f5f5;
      padding: 8px 12px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      border: 1px solid #ddd;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      display: inline-block;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
    }
    .file-list li:hover {
      background-color: #e6f7ff;
      border-color: #91d5ff;
      transform: translateY(-2px);
    }
    .clickable-file {
      position: relative;
    }
    .clickable-file::after {
      content: "üîç";
      margin-left: 5px;
      font-size: 10px;
      opacity: 0.7;
    }
    .modified-file {
      font-weight: bold;
      color: #28a745;
      position: relative;
    }
    .modified-file::after {
      content: "";
      background-color: #f9a825;
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-left: 8px;
    }
    .code-block {
      background-color: #f8f8f8;
      font-family: monospace;
      padding: 15px;
      border-radius: 4px;
      white-space: pre-wrap;
      overflow-x: auto;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #eee;
    }
    /* Chat bubble styles revamped for a sleek contemporary look */
    .chat-bubble {
      margin: 10px 0;
      padding: 12px 16px;
      border-radius: 20px;
      max-width: 80%;
      clear: both;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
      font-size: 14px;
      line-height: 1.5;
      transition: background 0.3s, box-shadow 0.3s;
    }
    .chat-user {
      background-color: #007bff;
      color: #ffffff;
      float: right;
      border-top-right-radius: 4px;
    }
    .chat-ai {
      background-color: #e9ecef;
      color: #333;
      float: left;
      border-top-left-radius: 4px;
    }
    .chat-clear {
      clear: both;
    }
    /* Ensure block and microphone buttons have identical dimensions for consistent UI */
    #blockButton, #micButton {
      width: 48px;
      height: 48px;
    }
    /* Styling for trusty agent prompts */
    .prompt-section {
      margin-bottom: 15px;
    }
    .agent-name {
      font-weight: 500;
      margin-bottom: 5px;
      color: #333;
      background-color: #f0f0f0;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 13px;
    }
    #trustyAgentPrompts .code-block {
      max-height: 200px;
      margin-bottom: 15px;
      font-size: 12px;
      background-color: #f8f8f8;
    }
    /* New overlay styles for file diff display */
    #fileDiffOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    #fileDiffContent {
      width: 90%;
      max-width: 1200px;
      height: 80%;
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #fileDiffHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      background-color: #f6f8fa;
      border-bottom: 1px solid #e1e4e8;
    }
    #fileDiffHeader h3 {
      margin: 0;
      font-size: 18px;
      color: #24292e;
    }
    #fileDiffCloseBtn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 20px;
      color: #586069;
    }
    #fileDiffCloseBtn:hover {
      color: #24292e;
    }
    #fileDiffBody {
      flex: 1;
      overflow: auto;
      padding: 20px;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.5;
      white-space: pre-wrap;
      background-color: #f8f8f8;
    }
    #fileDiffSplitView {
      display: flex;
      height: 100%;
      width: 100%;
      overflow: hidden;
      position: relative;
    }
    #fileDiffLeft, #fileDiffRight {
      flex: 1;
      padding: 10px 20px;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.5;
      white-space: pre-wrap;
      overflow-y: hidden;
    }
    #fileDiffLeft {
      background-color: #fffbf6;
      border-right: 1px solid #e1e4e8;
    }
    #fileDiffRight {
      background-color: #f6fffe;
    }
    #fileDiffScrollContainer {
      position: absolute;
      top: 0;
      right: 0;
      width: 15px;
      height: 100%;
      overflow-y: auto;
      z-index: 10;
    }
    #fileDiffScrollContent {
      height: 1000px; /* Will be adjusted dynamically */
    }
    .diff-line {
      display: flex;
      padding: 0 5px;
      border-radius: 3px;
      margin: 2px 0;
    }
    .diff-line-number {
      color: #999;
      text-align: right;
      user-select: none;
      padding-right: 10px;
      min-width: 40px;
      border-right: 1px solid #eee;
      margin-right: 10px;
      font-size: 12px;
    }
    .diff-line-content {
      flex: 1;
    }
    .diff-added-line {
      background-color: #e6ffed;
    }
    .diff-removed-line {
      background-color: #ffeef0;
    }
    .diff-section-header {
      background-color: #f1f8ff;
      padding: 5px;
      margin: 10px 0;
      color: #0366d6;
      font-weight: 500;
      border-bottom: 1px solid #c8e1ff;
    }
    .diff-file-header {
      background-color: #f1f8ff;
      padding: 8px 5px;
      margin: 15px 0 10px 0;
      color: #0366d6;
      font-weight: 500;
      border-bottom: 1px solid #c8e1ff;
      border-top: 1px solid #c8e1ff;
    }
    .diff-added {
      background-color: #e6ffed;
      color: #22863a;
      display: block;
      white-space: pre-wrap;
    }
    .diff-removed {
      background-color: #ffeef0;
      color: #cb2431;
      display: block;
      white-space: pre-wrap;
    }
    .diff-header {
      background-color: #f1f8ff;
      color: #0366d6;
      padding: 5px 0;
      margin: 10px 0;
      border-bottom: 1px solid #c8e1ff;
      display: block;
      white-space: pre-wrap;
    }
    .diff-unchanged {
      color: #24292e;
      display: block;
      white-space: pre-wrap;
    }
    .diff-section {
      margin-top: 20px;
      border-top: 1px solid #e1e4e8;
      padding-top: 10px;
      display: block;
    }
    .diff-error, .diff-empty {
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      display: block;
    }
    .diff-error {
      background-color: #ffeef0;
      border: 1px solid #fdb8c0;
      color: #cb2431;
    }
    .diff-empty {
      background-color: #f6f8fa;
      border: 1px solid #e1e4e8;
      color: #586069;
    }
    #fileDiffViewToggle {
      background-color: #f0f0f0;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      padding: 5px 10px;
      margin-right: 10px;
      cursor: pointer;
      font-size: 13px;
      color: #333;
      transition: background-color 0.2s;
    }
    #fileDiffViewToggle:hover {
      background-color: #e0e0e0;
    }
    #fileDiffViewToggle:active {
      background-color: #d0d0d0;
    }
    
    /* Style for filler lines in split view */
    .diff-filler {
      height: 22px; /* Match height of other lines */
      background-color: transparent;
      border-bottom: 1px solid rgba(0,0,0,0.05);
    }
    
    /* Ensure all diff lines have a consistent height */
    .diff-line {
      height: 22px;
      padding: 0 5px;
      margin: 0;
      border-bottom: 1px solid rgba(0,0,0,0.05);
      box-sizing: border-box;
      align-items: center;
    }
    
    /* Improve line number styling */
    .diff-line-number {
      color: #999;
      text-align: right;
      user-select: none;
      padding-right: 10px;
      min-width: 40px;
      border-right: 1px solid #eee;
      margin-right: 10px;
      font-size: 12px;
    }
    
    /* Git Operations Panel */
    #gitOperationsPanel {
      background-color: #f8f9fa;
      padding: 15px;
      border-top: 1px solid #e1e4e8;
      margin-top: 5px;
      margin-bottom: 10px;
    }
    
    .git-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
    }
    
    .git-button {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #d0d0d0;
      background-color: #f0f0f0;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
      width: 100%;
      text-align: center;
    }
    
    .git-button:hover {
      background-color: #e0e0e0;
    }
    
    .git-button:active {
      background-color: #d0d0d0;
    }
    
    .merge-container {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .branch-select {
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #d0d0d0;
      font-size: 14px;
      width: 100%;
    }
    
    #commitChangesBtn {
      background-color: #dff0d8;
      border-color: #c3e6cb;
      color: #155724;
    }
    
    #commitChangesBtn:hover {
      background-color: #c3e6cb;
    }
    
    #discardChangesBtn {
      background-color: #f8d7da;
      border-color: #f5c6cb;
      color: #721c24;
    }
    
    #discardChangesBtn:hover {
      background-color: #f5c6cb;
    }
    
    /* Line count badge styles */
    .line-count-badge {
      display: inline-flex;
      margin-left: 8px;
      font-size: 0.8em;
      border-radius: 4px;
      overflow: hidden;
    }
    
    .line-count-added {
      background-color: #c8e6c9;
      color: #2e7d32;
      padding: 2px 4px;
    }
    
    .line-count-removed {
      background-color: #ffcdd2;
      color: #c62828;
      padding: 2px 4px;
    }
    
    .clickable-file .line-count-badge {
      float: right;
      margin-right: 4px;
    }

    /* Trusty Agent Prompt overlay styles */
    #trustyAgentOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #trustyAgentContent {
      background-color: white;
      border-radius: 8px;
      width: 80%;
      max-width: 900px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
    }
    #trustyAgentHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      background-color: #f8f9fa;
      border-bottom: 1px solid #e9ecef;
    }
    #trustyAgentTitle {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #333;
    }
    #trustyAgentCloseBtn {
      font-size: 24px;
      cursor: pointer;
      border: none;
      background: transparent;
      color: #666;
      transition: color 0.2s;
    }
    #trustyAgentCloseBtn:hover {
      color: #333;
    }
    #trustyAgentBody {
      padding: 20px;
      overflow-y: auto;
      max-height: calc(90vh - 60px);
    }
    .trusty-agent-section {
      margin-bottom: 24px;
    }
    .trusty-agent-section-title {
      font-weight: 600;
      margin-bottom: 10px;
      font-size: 16px;
      color: #444;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
    }
    .code-block {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      font-family: 'Roboto Mono', monospace;
      white-space: pre-wrap;
      font-size: 14px;
      overflow-x: auto;
      border: 1px solid #e9ecef;
      max-height: 400px;
      overflow-y: auto;
    }
    
    #trustyAgentImageContainer {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    #mainImageContainer, 
    #comparisonImageContainer {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      border: 1px solid #e9ecef;
      text-align: center;
    }
    
    #mainImageContainer h4, 
    #comparisonImageContainer h4 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 14px;
      color: #555;
    }
    
    /* Style for trusty agent item in file list to show it's clickable */
    .trusty-agent-item {
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
      position: relative;
    }
    .trusty-agent-item::after {
      content: "üëÅÔ∏è";
      margin-left: 5px;
      font-size: 10px;
      opacity: 0.7;
    }
    .trusty-agent-item.has-results {
      background-color: #d4edda;
      border-color: #c3e6cb;
      color: #155724;
    }
    .trusty-agent-item.has-results::after {
      content: "üëÅÔ∏è";
      color: #155724;
    }
    .trusty-agent-item:hover {
      background-color: #e6f7ff;
      border-color: #91d5ff;
      transform: translateY(-2px);
    }
    .trusty-agent-item.has-results:hover {
      background-color: #c3e6cb;
      border-color: #a3d9a5;
    }
    
    /* Agent status styles */
    .agent-status {
      display: inline-block;
      margin-bottom: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: 500;
      font-size: 14px;
    }
    .agent-status.passed {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .agent-status.failed {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .agent-status.error {
      background-color: #fff3cd;
      color: #856404;
      border: 1px solid #ffeeba;
    }
    
    /* Agent type style */
    .agent-type {
      display: inline-block;
      margin-bottom: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      font-weight: 500;
      font-size: 12px;
      background-color: #e2e3e5;
      color: #383d41;
      border: 1px solid #d6d8db;
      margin-left: 10px;
    }
    
    /* Summary block style */
    .summary-block {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      border: 1px solid #eee;
      font-size: 14px;
      line-height: 1.5;
    }
  </style>
  <link rel="stylesheet" type="text/css" href="index.css">
</head>
<body>
  <div id="splitContainer">
    <div id="leftPanel">
      <div id="chatHeader">
        <div id="recipientName">tac.vibe</div>
        <div id="typingAnimation">
          <span class="dot"></span>
          <span class="dot"></span>
          <span class="dot"></span>
        </div>
        <div id="recipientStatus">
          <span class="statusDot"></span>
          <span id="statusText">connecting...</span>
        </div>
      </div>
      <div id="messageContainer"></div>
      <div id="gitOperationsPanel" style="display: none;">
        <div class="section-title">Git Operations</div>
        <div class="git-buttons">
          <button id="commitChangesBtn" class="git-button">Commit Changes</button>
          <button id="discardChangesBtn" class="git-button">Discard Changes</button>
          <div class="merge-container">
            <button id="mergeBtn" class="git-button">Merge with Branch</button>
            <select id="branchSelect" class="branch-select">
              <option value="">Select Branch</option>
            </select>
          </div>
        </div>
      </div>
      <div id="inputContainer">
        <textarea id="userInput" placeholder="Type your message here..." rows="2"></textarea>
        <div id="buttonContainer">
          <div id="micButton" class="action-button">üé§</div>
          <div id="blockButton" class="action-button">
            <canvas id="cubeCanvas" width="32" height="32"></canvas>
          </div>
        </div>
      </div>
    </div>
    <div id="rightPanel">
      <div id="runtimeStatus">Ready...</div>
      <div id="errorMessage"></div>
      <div id="infoMessage"></div>
      <div id="protoblockContainer">
        <!-- Protoblock container structure -->
        <div id="protoblockHeader">
          <h2>Protoblock</h2>
          <p id="protoblockAttempt">Attempt 1/4</p>
        </div>
        <div class="section">
          <div class="section-title">Task Description</div>
          <div id="taskDescription" class="code-block"></div>
        </div>
        <div class="section">
          <div class="section-title">Context Files</div>
          <ul id="contextFilesList" class="file-list"></ul>
        </div>
        <div class="section">
          <div class="section-title">Files to Modify</div>
          <ul id="writeFilesList" class="file-list"></ul>
        </div>
        <div class="section">
          <div class="section-title">Trusty Agents</div>
          <div id="trustyAgentsSection">
            <ul id="trustyAgentsList" class="file-list"></ul>
            
          </div>
        </div>
      </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script>
    // Initialize Three.js scene in the right panel
    const threeContainer = document.getElementById('rightPanel');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, threeContainer.clientWidth / threeContainer.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(threeContainer.clientWidth, threeContainer.clientHeight);
    renderer.setClearColor(0xe0eafc, 1);
    threeContainer.appendChild(renderer.domElement);

    // Create a polished cube with a refined material configured with wireframe: true
    const geometry = new THREE.BoxGeometry();
    const cubeMaterial = new THREE.MeshPhongMaterial({ 
      color: 0x0078d7, 
      shininess: 100, 
      wireframe: true, 
      transparent: true, 
      opacity: 0.7,
      emissive: 0x0078d7,
      emissiveIntensity: 0.5
    });
    const cube = new THREE.Mesh(geometry, cubeMaterial);
    // Center the cube horizontally within the scene
    cube.position.x = 0;
    scene.add(cube);

    // Add a wireframe overlay using EdgesGeometry and LineSegments for added style
    const edges = new THREE.EdgesGeometry(geometry);
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
    const wireframe = new THREE.LineSegments(edges, lineMaterial);
    cube.add(wireframe);

    // Position the camera and add lights for a refined look
    camera.position.set(3, 3, 5);
    camera.lookAt(0, 0, 0);
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    function animate() {
      requestAnimationFrame(animate);
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;
      renderer.render(scene, camera);
    }
    animate();

    // Function to toggle between 3D cube and protoblock display
    function toggleProtoblockDisplay(show) {
      const protoblockContainer = document.getElementById('protoblockContainer');
      const canvas = renderer.domElement;
      
      if (show) {
        canvas.style.display = 'none';
        protoblockContainer.style.display = 'block';
      } else {
        canvas.style.display = 'block';
        protoblockContainer.style.display = 'none';
      }
    }

    // Function to handle block execution failure
    function handleBlockFailure() {
      // Hide the protoblock display completely
      toggleProtoblockDisplay(false);
      
      // Reset any protoblock data displayed
      document.getElementById('protoblockContainer').innerHTML = '';
      
      // Rebuild the container structure
      rebuildProtoblockContainer();
      
      // Update the runtime status to show error
      document.getElementById("runtimeStatus").textContent = "Block execution failed";
    }
    
    // Function to rebuild the empty protoblock container structure
    function rebuildProtoblockContainer() {
      const container = document.getElementById('protoblockContainer');
      
      // Header
      const header = document.createElement('div');
      header.id = 'protoblockHeader';
      header.innerHTML = '<h2>Protoblock</h2><p id="protoblockAttempt">Attempt 1/4</p>';
      container.appendChild(header);
      
      // Task Description
      const taskSection = document.createElement('div');
      taskSection.className = 'section';
      taskSection.innerHTML = '<div class="section-title">Task Description</div>' +
                              '<div id="taskDescription" class="code-block"></div>';
      container.appendChild(taskSection);
      
      // Context Files
      const contextFilesSection = document.createElement('div');
      contextFilesSection.className = 'section';
      contextFilesSection.innerHTML = '<div class="section-title">Context Files</div>' +
                                     '<ul id="contextFilesList" class="file-list"></ul>';
      container.appendChild(contextFilesSection);
      
      // Files to Modify
      const writeFilesSection = document.createElement('div');
      writeFilesSection.className = 'section';
      writeFilesSection.innerHTML = '<div class="section-title">Files to Modify</div>' +
                                   '<ul id="writeFilesList" class="file-list"></ul>';
      container.appendChild(writeFilesSection);
      
      // Trusty Agents
      const trustyAgentsSection = document.createElement('div');
      trustyAgentsSection.className = 'section';
      trustyAgentsSection.innerHTML = '<div class="section-title">Trusty Agents</div>' +
                                     '<div id="trustyAgentsSection">' +
                                     '<ul id="trustyAgentsList" class="file-list"></ul>' +
                                     '</div>';
      container.appendChild(trustyAgentsSection);
    }

    // Function to display protoblock data
    function displayProtoblockData(data) {
      console.log("Displaying protoblock data:", data);
      
      // Ensure protoblock display is visible
      toggleProtoblockDisplay(true);
      
      // Update header
      document.getElementById('protoblockAttempt').textContent = `Attempt ${data.attempt}`;
      
      // Update task description
      document.getElementById('taskDescription').textContent = data.task_description;
      
      // Update files to modify
      const writeFilesList = document.getElementById('writeFilesList');
      writeFilesList.innerHTML = '';
      data.write_files.forEach(file => {
        const li = document.createElement('li');
        // Create text node to ensure we can reference just the filename later
        li.appendChild(document.createTextNode(file));
        writeFilesList.appendChild(li);
      });
      
      // Update context files
      const contextFilesList = document.getElementById('contextFilesList');
      contextFilesList.innerHTML = '';
      data.context_files.forEach(file => {
        const li = document.createElement('li');
        // Create text node to ensure we can reference just the filename later
        li.appendChild(document.createTextNode(file));
        contextFilesList.appendChild(li);
      });
      
      // Update trusty agents
      const trustyAgentsList = document.getElementById('trustyAgentsList');
      trustyAgentsList.innerHTML = '';
      
      // Store trusty agent prompts data globally to access when popup is opened
      window.trustyAgentPrompts = data.trusty_agent_prompts || {};
      
      // Store trusty agent results data globally to access when popup is opened
      window.trustyAgentResults = data.trusty_agent_results || {};
      
      // Log trusty agent results for debugging
      console.log("Trusty agent prompts:", window.trustyAgentPrompts);
      console.log("Trusty agent results:", window.trustyAgentResults);
      console.log("Trusty agents:", data.trusty_agents);
      
      // Combined display logic for trusty agents and their prompts
      if (data.trusty_agents && data.trusty_agents.length > 0) {
        // Always show all agents in the list
        trustyAgentsList.style.display = 'block';
        data.trusty_agents.forEach(agent => {
          const li = document.createElement('li');
          li.textContent = agent;
          
          // Convert agent name to lowercase for matching with results
          // This ensures consistency with how the backend stores keys
          const agentKey = agent.toLowerCase().replace(/agent$/, '');
          
          // Log whether this agent has results
          const hasPrompt = window.trustyAgentPrompts[agent];
          const resultObj = window.trustyAgentResults && 
                        (window.trustyAgentResults[agent] || window.trustyAgentResults[agentKey]);
          const hasResults = resultObj && (resultObj.output || resultObj.image_url);
          
          console.log(`Agent ${agent} (key: ${agentKey}): has prompt: ${!!hasPrompt}, has results: ${!!hasResults}`, resultObj);
          
          // Always make the agent clickable if it has a prompt (even without results)
          li.classList.add('trusty-agent-item');
            
          // Add has-results class if agent has results
          if (hasResults) {
            li.classList.add('has-results');
            console.log(`Adding has-results class to ${agent}`);
          }
            
          li.addEventListener('click', () => {
            // Get the latest protoblock data for the agent
            const protoblock = {
              trusty_agent_prompts: window.trustyAgentPrompts || {},
              trusty_agent_results: window.trustyAgentResults || {}
            };
            displayTrustyAgentPrompt(agent, protoblock);
          });
          
          trustyAgentsList.appendChild(li);
        });
      } else {
        // No agents at all
        const li = document.createElement('li');
        li.textContent = 'No trusty agents specified';
        trustyAgentsList.appendChild(li);
      }
      
      // Check if we should attempt to make files clickable (only after success)
      const runtimeStatus = document.getElementById('runtimeStatus');
      if (runtimeStatus.textContent.includes("‚úÖ")) {
        // Make files clickable after a delay to ensure the DOM is ready
        setTimeout(makeFilesClickable, 300);
      }
    }

    // Update renderer and camera on resize for rightPanel
    window.addEventListener('resize', () => {
      const width = threeContainer.clientWidth;
      const height = threeContainer.clientHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });

    // Chat functionality in the left panel
    const messageContainer = document.getElementById("messageContainer");
    const statusText = document.getElementById("statusText");
    const statusDot = document.querySelector("#recipientStatus .statusDot");
    const userInput = document.getElementById("userInput");
    const typingAnimation = document.getElementById("typingAnimation");
    const micButton = document.getElementById('micButton');
    const chatHeader = document.getElementById('chatHeader');

    function addChatMessage(sender, text) {
      const bubble = document.createElement("div");
      bubble.classList.add("chat-bubble");
      if (sender === "User") {
        bubble.classList.add("chat-user");
      } else if (sender === "AI") {
        bubble.classList.add("chat-ai");
      } else {
        // For System messages or others, no additional styling is applied.
      }
      bubble.textContent = text;
      messageContainer.appendChild(bubble);
      const clearDiv = document.createElement("div");
      clearDiv.classList.add("chat-clear");
      messageContainer.appendChild(clearDiv);
      messageContainer.scrollTop = messageContainer.scrollHeight;
    }

    function showTypingIndicator() {
      typingAnimation.style.display = "inline-flex";
    }

    function hideTypingIndicator() {
      typingAnimation.style.display = "none";
    }

    // Create WebSocket connection
    const socket = new WebSocket("ws://localhost:8765");

    // Connection opened
    socket.addEventListener('open', (event) => {
      console.log('Connected to WebSocket server');
      statusDot.style.backgroundColor = "#4caf50";
      statusText.textContent = "online";
      messageContainer.classList.remove("offline");
      chatHeader.classList.remove("offline");
    });
    
    // Handle WebSocket closure to indicate offline status (red indicator)
    socket.addEventListener('close', (event) => {
      console.log('WebSocket connection closed');
      statusDot.style.backgroundColor = "#f44336";
      statusText.textContent = "offline";
      messageContainer.classList.add("offline");
      chatHeader.classList.add("offline");
    });
    
    // Handle WebSocket errors to indicate offline status (red indicator)
    socket.addEventListener('error', (event) => {
      console.log('WebSocket error');
      statusDot.style.backgroundColor = "#f44336";
      statusText.textContent = "offline";
      messageContainer.classList.add("offline");
      chatHeader.classList.add("offline");
    });

    // Listen for messages from the server
    socket.addEventListener('message', (event) => {
      try {
        // Try to parse as JSON first
        const data = JSON.parse(event.data);
        
        if (data.type === "status_message") {
          // Update the right-side status text bar.
          document.getElementById("runtimeStatus").textContent = data.message;
          
          // Check for attempt number updates in status messages - support both formats
          const attemptMatch = data.message.match(/Starting (?:block creation and execution )?attempt (\d+) of (\d+)/);
          if (attemptMatch) {
            const current = attemptMatch[1];
            const max = attemptMatch[2];
            // Update the attempt number display in protoblock header
            document.getElementById('protoblockAttempt').textContent = `Attempt ${current}/${max}`;
            console.log(`Updated attempt number to ${current}/${max}`);
            
            // Don't hide the protoblock here - it will be replaced when the new one is created
          }
          
          // Check for block execution failure message
          if (data.message === "‚ùå Block execution failed!" || 
              data.message.startsWith("‚ùå Error:") ||
              data.message.includes("Error creating protoblock:") ||
              data.message.includes("Execution attempt") && data.message.includes("failed")) {
            console.log("Removing protoblock display due to failure message");
            // Force the canvas to be shown and protoblock to be hidden
            document.getElementById('protoblockContainer').style.display = 'none';
            document.querySelector('#rightPanel canvas').style.display = 'block';
            // Don't clear the data - just hide it
          }
          
          // Show git operations panel after successful block execution
          if (data.message === "‚úÖ Block executed successfully! Displaying final results...") {
            console.log("Block successful, showing git operations panel");
            showGitOperationsPanel(true);
          }
          
          return;
        } 
        else if (data.type === "error_message") {
          // Display prominent error message at the top of the right panel
          const errorMessage = document.getElementById("errorMessage");
          errorMessage.textContent = data.message;
          errorMessage.style.display = "block";
          
          // Apply a slight shake animation by removing and re-adding the class
          errorMessage.classList.remove("animated");
          void errorMessage.offsetWidth; // Force reflow to restart animation
          errorMessage.classList.add("animated");
          
          // Hide the error message after 30 seconds to allow plenty of time to read
          setTimeout(() => {
            errorMessage.style.display = "none";
          }, 30000);
          
          return;
        }
        else if (data.type === "info_message") {
          // Display info message at the bottom of the right panel
          const infoMessage = document.getElementById("infoMessage");
          infoMessage.textContent = data.message;
          infoMessage.style.display = "block";
          
          // Automatically hide after 15 seconds
          setTimeout(() => {
            infoMessage.style.display = "none";
          }, 15000);
          
          return;
        }
        else if (data.type === "remove_protoblock") {
          // This is an explicit message to remove the protoblock display
          console.log("Received explicit remove_protoblock message");
          
          // Force the canvas to be shown and protoblock to be hidden
          document.getElementById('protoblockContainer').style.display = 'none';
          document.querySelector('#rightPanel canvas').style.display = 'block';
          
          // Clear any existing protoblock data and rebuild the container
          document.getElementById('protoblockContainer').innerHTML = '';
          rebuildProtoblockContainer();
          
          // Update runtime status 
          document.getElementById("runtimeStatus").textContent = data.message || "Block processing complete";
          return;
        }
        else if (data.type === "protoblock_data") {
          // Display protoblock data in the right panel
          console.log("Received protoblock data:", data);
          
          // Ensure the protoblock container is visible
          document.getElementById('protoblockContainer').style.display = 'block';
          document.querySelector('#rightPanel canvas').style.display = 'none';
          
          // Display the data
          displayProtoblockData(data);
          
          console.log("Protoblock is now visible");
          return;
        }
        else if (data.type === "transcribed_message") {
          // Display as a user message
          addChatMessage("User", data.message);
          
          // Send it back to server for processing
          const payload = {
            type: "user_message",
            message: data.message
          };
          socket.send(JSON.stringify(payload));
          showTypingIndicator();

          // Remove any indication (waiting, recording, transcribing) from micButton once transcription is received
          micButton.classList.remove('waiting');
          micButton.classList.remove('recording');
          micButton.classList.remove('rotating');
          micButton.classList.remove('transcribing');
          return;
        }
        else if (data.type === "file_status_response" || 
                data.type === "file_diff_response" || 
                data.type === "git_branch_response" || 
                data.type === "git_operation_response") {
          // Ignore these types of messages - don't display in chat
          console.log(`Received ${data.type}`);
          return;
        }
        else {
          // Regular AI response
          addChatMessage("AI", event.data);
          // Immediately hide typing indicator after full display of AI message
          hideTypingIndicator();
        }
      } catch (e) {
        // If not JSON or parsing fails, treat as a regular message
        addChatMessage("AI", event.data);
        hideTypingIndicator();
      }
    });

    // Send user message when Enter key is pressed (without Shift)
    userInput.addEventListener("keydown", function(event) {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        const text = userInput.value.trim();
        if (text !== "") {
          // Display user's message in the chat history
          addChatMessage("User", text);
          
          // Format the message as JSON
          const payload = {
            type: "user_message",
            message: text
          };
          
          // Send the message to the server via WebSocket and show typing animation
          socket.send(JSON.stringify(payload));
          showTypingIndicator();
          userInput.value = "";
        }
      }
    });

    // Bind click event to the block button for cube-like interaction
    const blockButton = document.getElementById('blockButton');
    blockButton.addEventListener('click', function() {
      // Immediately update the runtime status to reflect the protoblock execution process.
      document.getElementById("runtimeStatus").textContent = "Executing protoblock";
      
      // Hide the protoblock display when starting a new block generation
      toggleProtoblockDisplay(false);
      
      // Clear any existing protoblock data
      document.getElementById('protoblockContainer').innerHTML = '';
      rebuildProtoblockContainer();
      
      // Add active class to trigger animation
      blockButton.classList.add('active');
      // Remove active class after a short delay to revert to original state
      setTimeout(() => {
        blockButton.classList.remove('active');
      }, 300);
      
      // If there is a message typed in, send it first to the chat system
      const text = userInput.value.trim();
      if (text !== "") {
        addChatMessage("User", text);
        const messagePayload = {
          type: "user_message",
          message: text
        };
        socket.send(JSON.stringify(messagePayload));
        showTypingIndicator();
        userInput.value = "";
      }
      
      // Initiate block processing by sending the block_click payload
      const payload = {
        type: "block_click"
      };
      socket.send(JSON.stringify(payload));
    });

    // Bind click event to the microphone button to send the 'mic_click' event to the backend
    let isRecording = false; // flag to track recording state

    micButton.addEventListener('click', function() {
      // Toggle the recording state
      isRecording = !isRecording;
      if (isRecording) {
        // Start recording: add 'recording' class to display red indicator and remove rotating if set
        micButton.classList.add('recording');
        micButton.classList.remove('rotating');
        micButton.classList.remove('transcribing');
      } else {
        // Stop recording: remove 'recording' class and add 'transcribing' class to indicate ongoing transcription
        micButton.classList.remove('recording');
        micButton.classList.remove('rotating');
        micButton.classList.add('transcribing');
      }
      const payload = {
        type: "mic_click",
        recording: isRecording
      };
      socket.send(JSON.stringify(payload));
    });

    // Initialize Three.js scene for the rotating cube inside the block button
    const btnCanvas = document.getElementById('cubeCanvas');
    const btnRenderer = new THREE.WebGLRenderer({ canvas: btnCanvas, antialias: true, alpha: true });
    btnRenderer.setPixelRatio(window.devicePixelRatio);
    btnRenderer.setClearColor(0x000000, 0);
    btnRenderer.setSize(32, 32);

    const btnScene = new THREE.Scene();
    const btnCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    btnCamera.position.z = 2;

    // Updated cube geometry dimensions for a visibly larger cube
    const btnGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
    const btnMaterial = new THREE.MeshPhongMaterial({ 
      color: 0x0078d7, 
      shininess: 100, 
      wireframe: true, 
      transparent: true, 
      opacity: 0.7,
      emissive: 0x0078d7, 
      emissiveIntensity: 0.5
    });
    const btnCube = new THREE.Mesh(btnGeometry, btnMaterial);
    btnScene.add(btnCube);

    const btnAmbient = new THREE.AmbientLight(0xffffff, 0.8);
    btnScene.add(btnAmbient);

    function animateBtnCube() {
      requestAnimationFrame(animateBtnCube);
      btnCube.rotation.x += 0.02;
      btnCube.rotation.y += 0.02;
      btnRenderer.render(btnScene, btnCamera);
    }
    animateBtnCube();

    // Initially hide the protoblock display
    toggleProtoblockDisplay(false);

    // Initialize the protoblock container structure
    rebuildProtoblockContainer();

    // Expose socket and cube for testing purposes
    window.socket = socket;
    window.cube = cube;
    
    // Git Operations Functionality
    let hasPendingChanges = false;
    let availableBranches = [];
    
    // Function to show git operations panel after successful block execution
    function showGitOperationsPanel(show) {
      const gitPanel = document.getElementById('gitOperationsPanel');
      const inputContainer = document.getElementById('inputContainer');
      
      if (!gitPanel) return;
      
      if (show) {
        // Show git panel and hide input
        gitPanel.style.display = 'block';
        inputContainer.style.display = 'none';
        
        // Request available branches
        requestBranchList();
        
        console.log("Git operations panel shown, chat input hidden");
      } else {
        // Hide git panel and show input
        gitPanel.style.display = 'none';
        inputContainer.style.display = 'flex';
        
        console.log("Git operations panel hidden, chat input shown");
      }
    }
    
    // Function to request list of available branches
    function requestBranchList() {
      if (socket && socket.readyState === WebSocket.OPEN) {
        const request = {
          type: "git_branch_request"
        };
        socket.send(JSON.stringify(request));
      }
    }
    
    // Function to handle commit changes button click
    function handleCommitChanges() {
      if (socket && socket.readyState === WebSocket.OPEN) {
        // Get the task description to use as commit message
        const taskDescription = document.getElementById('taskDescription').textContent.trim();
        const commitMsg = taskDescription.length > 50 
          ? taskDescription.substring(0, 47) + '...' 
          : taskDescription;
          
        // Show operation in progress
        document.getElementById("runtimeStatus").textContent = "Committing changes...";
        
        const request = {
          type: "git_commit_request",
          commit_message: commitMsg
        };
        socket.send(JSON.stringify(request));
      }
    }
    
    // Function to handle discard changes button click
    function handleDiscardChanges() {
      if (confirm("Are you sure you want to discard all changes?")) {
        if (socket && socket.readyState === WebSocket.OPEN) {
          // Show operation in progress
          document.getElementById("runtimeStatus").textContent = "Discarding changes...";
          
          const request = {
            type: "git_discard_request"
          };
          socket.send(JSON.stringify(request));
        }
      }
    }
    
    // Function to handle merge with branch button click
    function handleMergeBranch() {
      const branchSelect = document.getElementById('branchSelect');
      const selectedBranch = branchSelect.value;
      
      if (!selectedBranch) {
        alert("Please select a branch to merge with");
        return;
      }
      
      if (confirm(`Are you sure you want to merge changes into ${selectedBranch} and delete the current branch?`)) {
        if (socket && socket.readyState === WebSocket.OPEN) {
          // Show operation in progress
          document.getElementById("runtimeStatus").textContent = `Merging to ${selectedBranch}...`;
          
          const request = {
            type: "git_merge_request",
            target_branch: selectedBranch
          };
          socket.send(JSON.stringify(request));
        }
      }
    }
    
    // Wait for DOMContentLoaded to ensure all elements are available
    document.addEventListener('DOMContentLoaded', function() {
      // Set up git operation button event listeners
      const commitBtn = document.getElementById('commitChangesBtn');
      const discardBtn = document.getElementById('discardChangesBtn');
      const mergeBtn = document.getElementById('mergeBtn');
      
      if (commitBtn) {
        commitBtn.addEventListener('click', handleCommitChanges);
      }
      
      if (discardBtn) {
        discardBtn.addEventListener('click', handleDiscardChanges);
      }
      
      if (mergeBtn) {
        mergeBtn.addEventListener('click', handleMergeBranch);
      }
      
      // Listen for git-related responses
      socket.addEventListener('message', function(event) {
        try {
          const data = JSON.parse(event.data);
          
          // Handle git branch response
          if (data.type === "git_branch_response") {
            // Populate branch dropdown
            const branchSelect = document.getElementById('branchSelect');
            availableBranches = data.branches || [];
            
            // Clear existing options
            while (branchSelect.options.length > 1) {
              branchSelect.remove(1);
            }
            
            // Add new options
            availableBranches.forEach(branch => {
              const option = document.createElement('option');
              option.value = branch;
              option.textContent = branch;
              branchSelect.appendChild(option);
            });
          }
          
          // Handle git operation response
          else if (data.type === "git_operation_response") {
            if (data.success) {
              // Display success message
              document.getElementById("runtimeStatus").textContent = `‚úÖ ${data.message}`;
              
              // Update UI based on operation
              if (data.operation === "commit") {
                // Hide git panel after commit
                document.getElementById('gitOperationsPanel').style.display = 'none';
                
                // Wait a bit and disable entirely
                setTimeout(() => {
                  showGitOperationsPanel(false);
                }, 100);
              }
              else if (data.operation === "discard") {
                // Hide git panel and refresh the page to show original state
                document.getElementById('gitOperationsPanel').style.display = 'none';
                setTimeout(() => {
                  window.location.reload();
                }, 1000);
              }
              else if (data.operation === "merge") {
                // Hide git panel and refresh the page
                document.getElementById('gitOperationsPanel').style.display = 'none';
                setTimeout(() => {
                  window.location.reload();
                }, 1000);
              }
            } else {
              // Display error message
              document.getElementById("runtimeStatus").textContent = `‚ùå ${data.message}`;
            }
          }
        } catch (e) {
          // Not JSON
        }
      });
    });
  </script>
  
  <!-- File diff overlay -->
  <div id="fileDiffOverlay">
    <div id="fileDiffContent">
      <div id="fileDiffHeader">
        <h3 id="fileDiffTitle">File Changes</h3>
        <div>
          <button id="fileDiffViewToggle" title="Toggle between unified and split view">Split View</button>
          <button id="fileDiffCloseBtn">√ó</button>
        </div>
      </div>
      <div id="fileDiffBody"></div>
      <div id="fileDiffSplitView" style="display: none;">
        <div id="fileDiffLeft"></div>
        <div id="fileDiffRight"></div>
        <div id="fileDiffScrollContainer">
          <div id="fileDiffScrollContent"></div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Trusty Agent Prompt overlay -->
  <div id="trustyAgentOverlay">
    <div id="trustyAgentContent">
      <div id="trustyAgentHeader">
        <h3 id="trustyAgentTitle">Trusty Agent</h3>
        <button id="trustyAgentCloseBtn">√ó</button>
      </div>
      <div id="trustyAgentBody">
        <div class="trusty-agent-section">
          <div class="trusty-agent-section-title">Prompt</div>
          <div id="trustyAgentPromptText" class="code-block"></div>
        </div>
        <div class="trusty-agent-section" id="trustyAgentResultSection" style="display: none;">
          <div class="trusty-agent-section-title">Result</div>
          <div id="trustyAgentResultStatus" class="agent-status"></div>
          <div id="trustyAgentAgentType" class="agent-type"></div>
          <div id="trustyAgentResultText" class="code-block"></div>
        </div>
        <div class="trusty-agent-section" id="trustyAgentImageSection" style="display: none;">
          <div class="trusty-agent-section-title">Screenshots</div>
          <div id="trustyAgentImageContainer">
            <div id="mainImageContainer">
              <h4>Main Screenshot</h4>
              <img id="trustyAgentImage" alt="Trusty Agent Output Image" style="max-width: 100%; max-height: 400px;">
            </div>
            <div id="comparisonImageContainer" style="display: none; margin-top: 20px;">
              <h4>Comparison Screenshot</h4>
              <img id="trustyAgentComparisonImage" alt="Comparison Screenshot" style="max-width: 100%; max-height: 400px;">
            </div>
          </div>
        </div>
        <div class="trusty-agent-section" id="trustyAgentTestResultsSection" style="display: none;">
          <div class="trusty-agent-section-title">Test Results</div>
          <div id="trustyAgentTestResults" class="code-block"></div>
        </div>
        <div class="trusty-agent-section" id="trustyAgentSummarySection" style="display: none;">
          <div class="trusty-agent-section-title">Summary</div>
          <div id="trustyAgentSummary" class="summary-block"></div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // File diff handling
    const fileDiffOverlay = document.getElementById('fileDiffOverlay');
    const fileDiffCloseBtn = document.getElementById('fileDiffCloseBtn');
    const fileDiffBody = document.getElementById('fileDiffBody');
    const fileDiffTitle = document.getElementById('fileDiffTitle');
    const fileDiffSplitView = document.getElementById('fileDiffSplitView');
    const fileDiffLeft = document.getElementById('fileDiffLeft');
    const fileDiffRight = document.getElementById('fileDiffRight');
    const fileDiffViewToggle = document.getElementById('fileDiffViewToggle');

    let diffViewMode = 'unified'; // 'unified' or 'split'

    // Toggle between unified and split view
    fileDiffViewToggle.addEventListener('click', () => {
      if (diffViewMode === 'unified') {
        diffViewMode = 'split';
        fileDiffBody.style.display = 'none';
        fileDiffSplitView.style.display = 'flex';
        fileDiffViewToggle.textContent = 'Unified View';
        
        // Set proper height for scroll container after switching to split view
        setupSplitViewScrolling();
      } else {
        diffViewMode = 'unified';
        fileDiffBody.style.display = 'block';
        fileDiffSplitView.style.display = 'none';
        fileDiffViewToggle.textContent = 'Split View';
      }
    });
    
    // Function to set up synchronized scrolling
    function setupSplitViewScrolling() {
      const scrollContainer = document.getElementById('fileDiffScrollContainer');
      const scrollContent = document.getElementById('fileDiffScrollContent');
      const leftPane = document.getElementById('fileDiffLeft');
      const rightPane = document.getElementById('fileDiffRight');
      
      // Set height of scroll content based on line count
      if (window.currentDiffLineCount) {
        // Approximate line height of 22px
        scrollContent.style.height = (window.currentDiffLineCount * 22) + 'px';
      }
      
      // Synchronize panes with scroll container
      scrollContainer.onscroll = function() {
        leftPane.scrollTop = scrollContainer.scrollTop;
        rightPane.scrollTop = scrollContainer.scrollTop;
      };
    }

    // Function to parse a git diff and create the split view content
    function parseDiffForSplitView(diff) {
      const leftContent = [];
      const rightContent = [];
      
      // Regular expressions for parsing diff parts
      const fileHeaderRegex = /^diff --git a\/(.*) b\/(.*)$/;
      const hunkHeaderRegex = /^@@ -(\d+),(\d+) \+(\d+),(\d+) @@(.*)$/;
      
      let leftLineNumber = 1;
      let rightLineNumber = 1;
      let currentFile = '';
      let inHunk = false;
      let diffLineCount = 0;
      
      // Split the diff into lines
      const lines = diff.split('\n');
      
      // Add file header
      leftContent.push('<div class="diff-file-header">Original</div>');
      rightContent.push('<div class="diff-file-header">Modified</div>');
      diffLineCount++;
      
      // Process each line of the diff
      lines.forEach(line => {
        // Check for file header
        const fileHeaderMatch = line.match(fileHeaderRegex);
        if (fileHeaderMatch) {
          currentFile = fileHeaderMatch[1];
          leftContent.push(`<div class="diff-section-header">${currentFile}</div>`);
          rightContent.push(`<div class="diff-section-header">${currentFile}</div>`);
          diffLineCount++;
          return;
        }
        
        // Check for hunk header
        const hunkHeaderMatch = line.match(hunkHeaderRegex);
        if (hunkHeaderMatch) {
          const leftStart = parseInt(hunkHeaderMatch[1]);
          const rightStart = parseInt(hunkHeaderMatch[3]);
          
          inHunk = true;
          leftLineNumber = leftStart;
          rightLineNumber = rightStart;
          
          leftContent.push(`<div class="diff-section-header">${line}</div>`);
          rightContent.push(`<div class="diff-section-header">${line}</div>`);
          diffLineCount++;
          return;
        }
        
        // Skip other headers or non-content lines
        if (line.startsWith('---') || line.startsWith('+++') || line.startsWith('index ')) {
          return;
        }
        
        // Process content lines
        if (inHunk) {
          if (line.startsWith('-')) {
            // Line removed - show in left only
            leftContent.push(`
              <div class="diff-line diff-removed-line">
                <span class="diff-line-number">${leftLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            rightContent.push(`<div class="diff-line diff-filler"></div>`);
            leftLineNumber++;
            diffLineCount++;
          } else if (line.startsWith('+')) {
            // Line added - show in right only
            leftContent.push(`<div class="diff-line diff-filler"></div>`);
            rightContent.push(`
              <div class="diff-line diff-added-line">
                <span class="diff-line-number">${rightLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            rightLineNumber++;
            diffLineCount++;
          } else if (line.startsWith(' ')) {
            // Common line - show in both
            leftContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${leftLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            rightContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${rightLineNumber}</span>
                <span class="diff-line-content">${escapeHtml(line.substring(1))}</span>
              </div>
            `);
            leftLineNumber++;
            rightLineNumber++;
            diffLineCount++;
          } else if (line.trim() === '') {
            // Empty line - show in both
            leftContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${leftLineNumber}</span>
                <span class="diff-line-content"></span>
              </div>
            `);
            rightContent.push(`
              <div class="diff-line">
                <span class="diff-line-number">${rightLineNumber}</span>
                <span class="diff-line-content"></span>
              </div>
            `);
            leftLineNumber++;
            rightLineNumber++;
            diffLineCount++;
          }
        }
      });
      
      return {
        left: leftContent.join(''),
        right: rightContent.join(''),
        lineCount: diffLineCount
      };
    }

    // Helper function to escape HTML special characters
    function escapeHtml(unsafe) {
      return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
    }

    // Close overlay when clicking the close button
    fileDiffCloseBtn.addEventListener('click', () => {
      fileDiffOverlay.style.display = 'none';
    });

    // Close overlay when clicking outside the content
    fileDiffOverlay.addEventListener('click', (event) => {
      if (event.target === fileDiffOverlay) {
        fileDiffOverlay.style.display = 'none';
      }
    });

    // Function to fetch and show file diff
    async function showFileDiff(filename) {
      fileDiffTitle.textContent = `Changes in ${filename}`;
      fileDiffBody.innerHTML = 'Loading diff...';
      fileDiffLeft.innerHTML = 'Loading...';
      fileDiffRight.innerHTML = 'Loading...';
      fileDiffOverlay.style.display = 'flex';
      
      // Send WebSocket request for file diff
      requestFileDiff(filename);
    }

    // Function to make file list items clickable
    function makeFilesClickable() {
      const writeFilesList = document.getElementById('writeFilesList');
      const contextFilesList = document.getElementById('contextFilesList');
      
      console.log("Making files clickable");
      
      // Only apply click handlers if block execution was successful
      const runtimeStatus = document.getElementById('runtimeStatus');
      const isSuccess = runtimeStatus.textContent.includes("‚úÖ") || 
                       runtimeStatus.textContent.includes("successful") ||
                       runtimeStatus.textContent.includes("Ready");
      
      if (isSuccess) {
        // Make write files clickable
        const writeFileItems = writeFilesList.querySelectorAll('li');
        console.log(`Found ${writeFileItems.length} write files to make clickable`);
        
        writeFileItems.forEach(item => {
          // Remove existing event listeners by cloning the node
          const newItem = item.cloneNode(true);
          item.parentNode.replaceChild(newItem, item);
          
          // Extract just the filename without any badges or added elements
          const filename = newItem.childNodes[0].textContent.trim();
          
          newItem.classList.add('clickable-file');
          newItem.addEventListener('click', (event) => {
            // Prevent clicks on badges from triggering the diff view
            if (event.target.closest('.line-count-badge')) {
              return;
            }
            
            console.log(`Clicked on file: ${filename}`);
            showFileDiff(filename);
          });
          
          // Request file status to highlight modified files
          checkFileStatus(filename);
        });
        
        // Context files should NOT be clickable in the same way write files are
        const contextFileItems = contextFilesList.querySelectorAll('li');
        console.log(`Found ${contextFileItems.length} context files`);
        
        contextFileItems.forEach(item => {
          // Remove any clickable styling or event listeners
          const newItem = item.cloneNode(true);
          item.parentNode.replaceChild(newItem, item);
          
          // Make them non-clickable by default
          newItem.classList.remove('clickable-file');
          newItem.classList.remove('modified-file');
          
          // Still check file status, but don't make them clickable for diffs
          const filename = newItem.childNodes[0].textContent.trim();
          checkFileStatus(filename);
        });
      } else {
        console.log("Block execution not successful, not making files clickable");
      }
    }

    // Function to check if a file has been modified
    function checkFileStatus(filename) {
      if (socket && socket.readyState === WebSocket.OPEN) {
        const request = {
          type: "file_status_request",
          filename: filename
        };
        socket.send(JSON.stringify(request));
      }
    }

    // Function to send message to server to request file diff
    function requestFileDiff(filename) {
      if (socket && socket.readyState === WebSocket.OPEN) {
        const request = {
          type: "file_diff_request",
          filename: filename
        };
        socket.send(JSON.stringify(request));
      }
    }

    // Update the displayProtoblockData function to make files clickable
    const originalDisplayProtoblockData = displayProtoblockData;
    displayProtoblockData = function(data) {
      // Call the original function
      originalDisplayProtoblockData(data);
      
      // Check if this is a successful block execution
      const runtimeStatus = document.getElementById('runtimeStatus');
      const isSuccess = runtimeStatus.textContent.includes("‚úÖ") || 
                       runtimeStatus.textContent.includes("successful");
                       
      if (isSuccess) {
        // Make files clickable after a delay to ensure the DOM is ready
        setTimeout(makeFilesClickable, 300);
      }
    };

    // Add handling for file_status_response messages
    socket.addEventListener('message', (event) => {
      try {
        const data = JSON.parse(event.data);
        
        if (data.type === "file_status_response") {
          // Handle file status update
          const { filename, is_modified, error, added_lines, removed_lines } = data;
          
          if (error) {
            console.log(`Error checking status for ${filename}: ${error}`);
            return;
          }
          
          // Find the file item in both lists
          const allFileLists = [
            document.getElementById('writeFilesList'),
            document.getElementById('contextFilesList')
          ];
          
          allFileLists.forEach(list => {
            if (!list) return;
            
            const items = list.querySelectorAll('li');
            items.forEach(item => {
              // Extract the actual filename from the first text node
              let itemFilename = '';
              if (item.childNodes.length > 0 && item.childNodes[0].nodeType === Node.TEXT_NODE) {
                itemFilename = item.childNodes[0].textContent.trim();
              } else {
                itemFilename = item.textContent.trim();
              }
              
              if (itemFilename === filename.trim()) {
                // For context files, we don't want to highlight them as modified
                if (list.id === 'contextFilesList') {
                  // Don't add modification styling to context files
                  return;
                }
                
                // Update class based on modification status
                if (is_modified) {
                  item.classList.add('modified-file');
                  
                  // Add line counts if available
                  if (added_lines > 0 || removed_lines > 0) {
                    // Create line count display
                    let lineCountHTML = '';
                    
                    if (added_lines > 0) {
                      lineCountHTML += `<span class="line-count-added">+${added_lines}</span>`;
                    }
                    
                    if (removed_lines > 0) {
                      lineCountHTML += `<span class="line-count-removed">-${removed_lines}</span>`;
                    }
                    
                    // Add the line count badge
                    const badge = document.createElement('span');
                    badge.className = 'line-count-badge';
                    badge.innerHTML = lineCountHTML;
                    
                    // Remove any existing badge first
                    const existingBadge = item.querySelector('.line-count-badge');
                    if (existingBadge) {
                      item.removeChild(existingBadge);
                    }
                    
                    // Add new badge
                    item.appendChild(badge);
                  }
                } else {
                  item.classList.remove('modified-file');
                  // Remove any existing line count badge
                  const existingBadge = item.querySelector('.line-count-badge');
                  if (existingBadge) {
                    item.removeChild(existingBadge);
                  }
                }
              }
            });
          });
        }
      } catch (e) {
        // Not JSON or not a file_status_response
      }
    });

    // When we get a file_diff_response, handle both unified and split views
    socket.addEventListener('message', (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.type === "file_diff_response") {
          // Display the diff in the overlay
          fileDiffTitle.textContent = `Changes in ${data.filename}`;
          
          // Format and display the diff with syntax highlighting
          let formattedDiff = '';
          
          if (data.error) {
            formattedDiff = `<div class="diff-error">Error: ${data.error}</div>`;
            fileDiffBody.innerHTML = formattedDiff;
            fileDiffLeft.innerHTML = formattedDiff;
            fileDiffRight.innerHTML = formattedDiff;
          } else if (!data.diff || data.diff.trim() === '') {
            formattedDiff = '<div class="diff-empty">No changes detected for this file.</div>';
            fileDiffBody.innerHTML = formattedDiff;
            fileDiffLeft.innerHTML = formattedDiff;
            fileDiffRight.innerHTML = formattedDiff;
          } else {
            // Handle the case where diff is just file content
            if (data.diff.startsWith("Full file content") || data.diff.startsWith("File is tracked")) {
              // Simple content display
              const content = data.diff.replace(/^Full file content.*?\n/g, '');
              formattedDiff = `<div class="diff-section">${data.diff.split('\n')[0]}</div>`;
              formattedDiff += `<pre class="diff-unchanged">${escapeHtml(content)}</pre>`;
              
              // For split view, show the same content on both sides
              fileDiffLeft.innerHTML = `<div class="diff-file-header">Original</div><pre>${escapeHtml(content)}</pre>`;
              fileDiffRight.innerHTML = `<div class="diff-file-header">Modified</div><pre>${escapeHtml(content)}</pre>`;
              window.currentDiffLineCount = content.split('\n').length + 5; // +5 for headers
            } else {
              // Process the diff for unified view
              const diffLines = data.diff.split('\n');
              let inSection = false;
              
              diffLines.forEach(line => {
                if (line.startsWith("=== ") && line.endsWith(" ===")) {
                  // Section header (staged/unstaged)
                  formattedDiff += `<div class="diff-section">${line}</div>`;
                  inSection = true;
                } else if (line.startsWith('+') && !line.startsWith('+++')) {
                  formattedDiff += `<div class="diff-added">${escapeHtml(line)}</div>`;
                } else if (line.startsWith('-') && !line.startsWith('---')) {
                  formattedDiff += `<div class="diff-removed">${escapeHtml(line)}</div>`;
                } else if (line.startsWith('@@')) {
                  formattedDiff += `<div class="diff-header">${escapeHtml(line)}</div>`;
                } else if (line.startsWith('diff') || line.startsWith('---') || line.startsWith('+++')) {
                  formattedDiff += `<div class="diff-header">${escapeHtml(line)}</div>`;
                } else {
                  formattedDiff += `<div class="diff-unchanged">${escapeHtml(line)}</div>`;
                }
              });
              
              // Create split view
              const splitViewContent = parseDiffForSplitView(data.diff);
              fileDiffLeft.innerHTML = splitViewContent.left;
              fileDiffRight.innerHTML = splitViewContent.right;
              window.currentDiffLineCount = splitViewContent.lineCount;
            }
            
            fileDiffBody.innerHTML = formattedDiff;
          }
          
          fileDiffOverlay.style.display = 'flex';
          
          // Set the view mode according to current setting
          if (diffViewMode === 'unified') {
            fileDiffBody.style.display = 'block';
            fileDiffSplitView.style.display = 'none';
            fileDiffViewToggle.textContent = 'Split View';
          } else {
            fileDiffBody.style.display = 'none';
            fileDiffSplitView.style.display = 'flex';
            fileDiffViewToggle.textContent = 'Unified View';
            // Setup synchronized scrolling
            setupSplitViewScrolling();
          }
        }
      } catch (e) {
        // Not JSON or not a file diff response
        console.log("Error parsing message:", e);
      }
    });

    // Trusty Agent Prompt Overlay functionality
    const trustyAgentOverlay = document.getElementById('trustyAgentOverlay');
    const trustyAgentCloseBtn = document.getElementById('trustyAgentCloseBtn');
    const trustyAgentBody = document.getElementById('trustyAgentBody');
    const trustyAgentTitle = document.getElementById('trustyAgentTitle');

    // Function to show a specific trusty agent prompt
    function showTrustyAgentPrompt(agentName, agentKey) {
      console.log(`Showing prompt for agent: ${agentName} (key: ${agentKey})`);
      
      // Set the title
      trustyAgentTitle.textContent = `${agentName}`;
      
      // Get the prompt
      const prompt = window.trustyAgentPrompts[agentName] || '';
      console.log(`Prompt for ${agentName}:`, prompt ? 'exists' : 'not found');
      
      // Get the results (if any)
      // Try both the full name and the key name to match backend storage
      const results = window.trustyAgentResults && 
                     (window.trustyAgentResults[agentName] || window.trustyAgentResults[agentKey] || null);
      
      console.log(`Results for ${agentName}:`, results || 'not found');
      
      // Set the prompt text
      const promptTextElement = document.getElementById('trustyAgentPromptText');
      promptTextElement.textContent = prompt || 'No prompt available for this agent.';
      
      // Process results if available
      const resultSection = document.getElementById('trustyAgentResultSection');
      const resultTextElement = document.getElementById('trustyAgentResultText');
      const resultStatusElement = document.getElementById('trustyAgentResultStatus');
      const imageSection = document.getElementById('trustyAgentImageSection');
      const imageElement = document.getElementById('trustyAgentImage');
      
      // Get the runtime status to check if execution was successful
      const runtimeStatus = document.getElementById('runtimeStatus');
      const executionSuccessful = runtimeStatus.textContent.includes("‚úÖ");
      
      if (results && (results.output || results.image_url)) {
        console.log(`${agentName} has results to display`);
        
        // Show result section if there's output text
        if (results.output) {
          console.log(`${agentName} output:`, results.output);
          resultSection.style.display = 'block';
          resultTextElement.textContent = results.output;
          
          // Set status indicator
          if (results.status) {
            resultStatusElement.className = 'agent-status ' + results.status;
            let statusText = '';
            switch (results.status) {
              case 'passed':
                statusText = 'Verification Passed ‚úÖ';
                break;
              case 'failed':
                statusText = 'Verification Failed ‚ùå';
                break;
              case 'error':
                statusText = 'Execution Error ‚ö†Ô∏è';
                break;
              default:
                statusText = results.status;
            }
            resultStatusElement.textContent = statusText;
            resultStatusElement.style.display = 'inline-block';
          } else {
            resultStatusElement.style.display = 'none';
          }
        } else {
          resultSection.style.display = 'none';
        }
        
        // Show image section if there's an image URL
        if (results.image_url) {
          console.log(`${agentName} image URL:`, results.image_url);
          imageSection.style.display = 'block';
          imageElement.src = results.image_url;
        } else {
          imageSection.style.display = 'none';
        }
      } else {
        console.log(`${agentName} has no results to display`);
        
        // Show message based on execution status
        resultSection.style.display = 'block';
        resultStatusElement.style.display = 'none';
        
        if (executionSuccessful) {
          // Execution was successful but no results for this agent
          resultTextElement.innerHTML = '<div class="diff-empty">This agent was executed but did not produce any output.</div>';
        } else {
          // Execution may still be in progress or failed
          resultTextElement.innerHTML = '<div class="diff-empty">No results available yet for this agent.</div>';
        }
        
        imageSection.style.display = 'none';
      }
      
      // Show the overlay
      trustyAgentOverlay.style.display = 'flex';
    }

    // Close overlay when clicking the close button
    trustyAgentCloseBtn.addEventListener('click', () => {
      trustyAgentOverlay.style.display = 'none';
    });

    // Close overlay when clicking outside the content
    trustyAgentOverlay.addEventListener('click', (event) => {
      if (event.target === trustyAgentOverlay) {
        trustyAgentOverlay.style.display = 'none';
      }
    });

    function displayTrustyAgentPrompt(agentName, protoblock) {
      console.log("Displaying prompt for agent:", agentName);
      const trustyAgentOverlay = document.getElementById('trustyAgentOverlay');
      const trustyAgentTitle = document.getElementById('trustyAgentTitle');
      const trustyAgentPromptText = document.getElementById('trustyAgentPromptText');
      const trustyAgentResultSection = document.getElementById('trustyAgentResultSection');
      const trustyAgentResultText = document.getElementById('trustyAgentResultText');
      const trustyAgentImageSection = document.getElementById('trustyAgentImageSection');
      const trustyAgentImage = document.getElementById('trustyAgentImage');
      const trustyAgentAgentType = document.getElementById('trustyAgentAgentType');
      const trustyAgentResultStatus = document.getElementById('trustyAgentResultStatus');
      const trustyAgentComparisonImage = document.getElementById('trustyAgentComparisonImage');
      const comparisonImageContainer = document.getElementById('comparisonImageContainer');
      const trustyAgentTestResultsSection = document.getElementById('trustyAgentTestResultsSection');
      const trustyAgentTestResults = document.getElementById('trustyAgentTestResults');
      const trustyAgentSummarySection = document.getElementById('trustyAgentSummarySection');
      const trustyAgentSummary = document.getElementById('trustyAgentSummary');

      // Display the overlay
      trustyAgentOverlay.style.display = 'flex';

      // Set the title
      trustyAgentTitle.textContent = `Trusty Agent: ${agentName}`;

      // Set the prompt text
      const agentKey = agentName.toLowerCase();
      let agentPrompt = "";

      // Check if the prompt exists for the agent
      let hasPrompt = false;
      if (protoblock.trusty_agent_prompts && protoblock.trusty_agent_prompts[agentKey]) {
        hasPrompt = true;
        agentPrompt = protoblock.trusty_agent_prompts[agentKey];
      }

      trustyAgentPromptText.textContent = hasPrompt ? agentPrompt : "No prompt found for this agent.";

      // Check if there are results for this agent
      let resultObj = null;
      let hasResults = false;
      
      if (protoblock.trusty_agent_results) {
        console.log("Available trusty agent results:", Object.keys(protoblock.trusty_agent_results));
        
        if (protoblock.trusty_agent_results[agentKey]) {
          resultObj = protoblock.trusty_agent_results[agentKey];
          hasResults = (resultObj.output !== undefined || resultObj.image_url !== undefined);
          console.log(`Found results for ${agentKey}:`, resultObj);
        }
      }

      // Display or hide the result section based on whether there are results
      if (hasResults && resultObj) {
        trustyAgentResultSection.style.display = 'block';
        
        // Set status badge
        if (resultObj.status) {
          trustyAgentResultStatus.textContent = resultObj.status;
          trustyAgentResultStatus.className = 'agent-status';
          if (resultObj.status.toLowerCase() === 'passed') {
            trustyAgentResultStatus.classList.add('passed');
          } else if (resultObj.status.toLowerCase() === 'failed') {
            trustyAgentResultStatus.classList.add('failed');
          } else {
            trustyAgentResultStatus.classList.add('error');
          }
        } else {
          trustyAgentResultStatus.textContent = '';
          trustyAgentResultStatus.className = 'agent-status';
        }
        
        // Set agent type if available
        if (resultObj.agent_type) {
          trustyAgentAgentType.textContent = resultObj.agent_type;
          trustyAgentAgentType.style.display = 'inline-block';
        } else {
          trustyAgentAgentType.style.display = 'none';
        }
        
        // Set result text content
        trustyAgentResultText.textContent = resultObj.output || "No text output available";

        // Check if there's an image URL and display it
        if (resultObj.image_url) {
          trustyAgentImageSection.style.display = 'block';
          trustyAgentImage.src = resultObj.image_url;
        } else {
          trustyAgentImageSection.style.display = 'none';
        }
        
        // Check for comparison image
        if (resultObj.comparison_path) {
          comparisonImageContainer.style.display = 'block';
          trustyAgentComparisonImage.src = resultObj.comparison_path;
        } else {
          comparisonImageContainer.style.display = 'none';
        }
        
        // Check for test results
        if (resultObj.test_results) {
          trustyAgentTestResultsSection.style.display = 'block';
          trustyAgentTestResults.textContent = resultObj.test_results;
        } else {
          trustyAgentTestResultsSection.style.display = 'none';
        }
        
        // Check for summary
        if (resultObj.summary) {
          trustyAgentSummarySection.style.display = 'block';
          trustyAgentSummary.textContent = resultObj.summary;
        } else {
          trustyAgentSummarySection.style.display = 'none';
        }
      } else {
        trustyAgentResultSection.style.display = 'none';
        trustyAgentImageSection.style.display = 'none';
        trustyAgentTestResultsSection.style.display = 'none';
        trustyAgentSummarySection.style.display = 'none';
        console.log(`No results found for agent: ${agentKey}`);
      }

      // Set up the close button event listener
      const trustyAgentCloseBtn = document.getElementById('trustyAgentCloseBtn');
      trustyAgentCloseBtn.onclick = function() {
        trustyAgentOverlay.style.display = 'none';
      };
    }
  </script>
</body>
</html>